# 目录 
* JS
* CSS
* HTML   TODO🔥
* 浏览器
* 手写题


============================================== fJS ==============================================
# f原型
## 1.讲概念
### 原型
每个由构造函数创建的对象，都拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。
### 原型链
原型对象也可能拥有原型，并从中继承方法和属性，一层一层以此类推，这样的关系被称为原型链，它解释了为什么在 JS 中一个对象会拥有，定义在其他对象中的属性和方法。
## 2.注意点
一般来说，对象不应该能够获取到原型，不过现在浏览器中都实现了 __proto__ 属性来访问这个属性，但是最好不要使用这个属性，因为这个属性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。我们可以使用 Object.getPrototypeOf() 方法来获取对象的原型。
## 3.缺点
在原型链上查找属性会比较耗时，对性能有副作用，这在性能要求严苛的场景下影响很大。比如，用for...in 遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。
## 4.解决方案
要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，可以使用从 Object.prototype 继承的 hasOwnProperty 方法，这样避免了查找原型链，可以提升一些性能。

## f坑爹原型题 (聊完 原型 大概率会做这些坑爹题)
关键: 现在操作的是`函数`还是`对象`。
### 函数
1. `函数.__proto__ === Function.prototype`
2. `Foo.constructor === Function` => `Function.constructor === Function`  环
### 对象
1. `xx.prototype.__proto__ === Object.prototype`。
2. `Object.prototype.__proto === null`  单链表


## f继承 (聊完 原型 可能会让我手写)
### 寄生组合继承
这个是用 ES5 实现继承比较好的方式，优点:
1. 没有父类的实例属性。
2. 一个原型对象共享给多个实例。
```js
// 父类
function Father() {}
// 子类
function Son() {}
// 通过寄生方式，砍掉父类的实例属性，避免了组合继承生成两份实例的缺点
Son.prototype = Object.create(Father.prototype);
// 修复构造函数指向
Son.prototype.constructor = Son;
```
### class继承
ECMA-262 规范推荐的写法，注意两点:
1. 使用extends表明继承自哪个父类。
2. 在子类构造函数中必须调用super。
```js
class Son extends Father {
  constructor(name) {
    super(name);
    this.name = name || "son";
  }
}
```

# f作用域
## 1.讲概念
### 作用域
作用域分为全局作用域、函数作用域、以及 ES6 的块级作用域。 作用域是对变量可访问范围的限制，内层作用域可以访问外层作用域，但是反过来，外层作用域是不可以访问内层作用域的。
### 作用域链
在当前作用域中查找变量，如果没有找到，就去父级作用域查找，找不到就再往上，一直找到全局作用域为止，这一层层关系形成了一条链，这就是作用域链。
### 预解析
预解析(Hoisting) 是伴随作用域的概念。在JS代码执行之前，也就是编译阶段，先把var变量的声明和函数的声明，提升到当前作用域的顶部。这样即使函数声明写在函数使用的后面，也可以正常执行。
注意: 当一个函数遇到一个同名的值为undefined的变量，会忽略掉这个undefined变量，所以同名的变量和函数都提升时，函数会覆盖掉这个变量。
## 2.说用途
作用域链的作用是保证对`执行环境有权访问的所有变量`和`函数`的`有序访问`，通过作用域链，可以一层层按顺序访问到外层环境的变量和函数。

# f执行上下文
## 1.讲概念
执行上下文分为全局执行上下文、函数执行上下文、eval执行上下文。
### 全局执行上下文
任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。
### 函数执行上下文
当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。
### eval上下文
执行在eval函数中的代码会有属于他自己的执行上下文。
## 2.说用途
JavaScript解释器开始执行代码时，首先会创建全局执行上下文，后面每次调用一个函数，都会创建一个新的执行上下文。
每次创建一个执行上下文时，该执行上下文就会被添加到调用栈的顶部。浏览器总是执行位于调用栈链顶部的执行上下文，一旦执行完毕，该执行上下文就会从调用栈中弹出，然后控制权来到栈的下一个执行上下文中。

# f闭包
## 1.讲概念
一个函数和对其周围状态的引用捆绑在一起，这样的组合就是闭包。也就是说，闭包可以在一个内层函数中访问到外层函数的作用域。在 JS 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。
## 2.说用途
闭包可以模拟私有属性和私有方法，常用的场景有防抖、节流等场景。
## 3.使用闭包的注意点
如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。
闭包不会造成内存泄漏，代码写错了才会造成内存泄漏。
## 聊到这里可能让我手写 防抖与节流
```js
// 防抖: 短时间内多次触发，只执行最后一次  (immediate参数控制首次是否触发)
function debounce(fn, time, immediate = false) {
  let timer = null;
  return function () {
    if (immediate) {
      fn();
      immediate = false;
      return;
    }
    if (timer !== null) {
      clearTimeout(timer);  // 清除上次延时任务，重新设置一次
    }
    timer = setTimeout(() => {
      fn();
      timer = null;
    }, time);
  }
}
// 节流: 持续触发，每隔一段时间执行一次
function throttle(fn, time) {
  let last = new Date();
  return function () {
    const now = new Date();
    if (now - last >= time) {  // 间隔时间后才触发
      fn();
      last = now;
    }
  }
}
```

# f内存泄漏
## 1.讲概念
内存泄漏是指程序中已分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃。
## 2.特点
内存泄漏缺陷具有隐蔽性、积累性的特征，比其他内存非法访问错误更难检测。因为内存泄漏的产生原因是内存块未被释放，属于遗漏型缺陷而不是过错型缺陷。
内存泄漏通常不会直接产生可观察的错误症状，而是逐渐积累，降低系统整体性能，极端的情况下可能使系统崩溃。
## 3.如何防止内存泄漏
1. 检查是否有意外的全局变量没有清除。
2. 清除定时器内部的变量。比如设置了 setInterval 而忘记取消，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中无法被回收。
3. 在低版本的浏览器环境下，要防止循环引用。某些低版本浏览器的垃圾回收机制还在使用引用计数，循环引用的内存无法释放，会造成内存泄漏。

# f垃圾回收
## 1.讲概念
JavaScript在创建变量时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。
垃圾回收算法主要依赖于`引用`的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限，不管是隐式还是显式的，都叫做一个对象引用另一个对象。例如，一个 `Javascript`对象具有对它原型的引用，这是隐式引用，还有对它属性的引用，这是显式引用。
## 2.说用途
浏览器的垃圾回收算法主要有两种 ——  引用计数 和 标记清除。
### 2-1. 引用计数
这个是最初级的垃圾收集算法，它的理念是: 把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它`。如果没有`引用`指向该对象，对象将被垃圾回收机制回收。
#### 引用计数的限制 -- 循环引用
`引用计数`无法处理`循环引用`的情况。比如在一个函数中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。
### 2-2. 标记清除
这个算法把`对象是否不再需要`简化定义为`对象是否可以获得`。
这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……。从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象，`不能获取的对象`视为垃圾数据，它们所占的内存就可以回收了。
#### 标记清除 解决 循环引用
`标记清除`可以有效解决`循环引用`的问题: 从全局对象触发，无法获取互相引用的两个对象，因此，他们将会被垃圾回收器回收。


# fbind/call/apply
## 1.讲概念
### bind
bind 方法创建一个新的函数，在 bind 被调用时，这个新函数的 this 被指定为 bind 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。
### call
call 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。
### apply
apply 方法调用一个具有给定this值的函数，以及以一个数组（或类数组对象）的形式提供的参数。
## 2.注意点
已经被 bind 绑定 this 的函数，再通过 call或者 apply 传入 this 来执行，传入的 this 是不会生效的，生效的只有 bind 的 this。包括连续的 bind，也只有第一次 bind 会生效， this 永远指向第一次 bind 的参数。
## 手写 (大概率会写)
```js
Function.prototype.myApply = function () {
  // 要判断一下，因为有可能有这种情况:
  // const o = {};  Object.setPrototypeOf(o, Function.prototype);
  if (typeof this !== 'function') {
    throw new TypeError('this is not a function');
  }
  // 没传就是 window
  const ctx = arguments[0] || window;
  // arguments[1] 传的必须是数组
  const args = arguments[1] ? [...arguments[1]] : [];
  // 挂到 context 上，使 fn 以 context 为 this 执行。
  // 担心 context 会有重复变量名，为了不覆盖它，用 Symbol 生成一个唯一的属性名
  // 这样既不影响原对象，又能达到 apply 的目的
  const fnName = Symbol('fnName');
  ctx[fnName] = this;
  // 执行
  const result = ctx[fnName](...args);
  // 删掉挂上去的属性
  delete ctx[fnName];
  // 返回结果
  return result;
}
Function.prototype.myCall = function () {
  // 要判断一下，因为有可能有这种情况:
  // const o = {};  Object.setPrototypeOf(o, Function.prototype);
  if (typeof this !== 'function') {
    throw new TypeError('this is not a function');
  }
  // 没传就是 window
  const ctx = arguments[0] || window;
  // 传的必须是数组，没传就是空数组
  // arguments 不是数组，没有 slice 方法，所以要借用空数组
  const args = [].slice.call(arguments, 1);
  // 挂到 context 上，使 fn 以 context 为 this 执行。
  // 担心 context 会有重复变量名，为了不覆盖它，用 Symbol 生成一个唯一的属性名
  // 这样既不影响原对象，又能达到 apply 的目的
  const fnName = Symbol('fnName');
  ctx[fnName] = this;
  // 执行
  const result = ctx[fnName](...args);
  // 删掉挂上去的属性
  delete ctx[fnName];
  // 返回结果
  return result;
}
// 注意 bind 的特性:
// 1. 当成普通函数使用，此时 bind 生效。
// 2. 当成构造函数使用，此时 bind 无效。
Function.prototype.myBind = function (context) {
  // 要判断一下，因为有可能有这种情况:
  // const o = {};  Object.setPrototypeOf(o, Function.prototype);
  if (typeof this !== 'function') {
    throw new TypeError('this is not a function');
  }
  // 待绑定的函数
  const fToBind = this;
  // 用于绑定原型链
  const fNop = function () { };
  // 转成数组
  const outerArgs = [].slice.call(arguments, 1);
  // 返回新的绑定函数
  function fBound() {
    // 将 arguments 转成 真正的数组
    const innerArgs = [].slice.call(arguments);
    // 如果是 new，this 是以 fBound 为构造函数，创建的实例（类比于 [] instanceof Array）
    // 如果不是 new，this 一般是 window
    // 检查是不是 new，从而决定用不用外来 this (context)
    return fToBind.apply(this instanceof fBound ? this : context, outerArgs.concat(innerArgs));
  }
  // 将"待绑定函数"视为构造函数，保存它的原型链，以防后续的 new 操作
  if (fToBind.prototype) {
    fNop.prototype = fToBind.prototype;
  }
  fBound.prototype = new fNop();

  return fBound;
}
```

# fNew
## 1. 讲概念 --  new 的时候发生了什么
1. 以 构造函数的原型对象为原型，创建一个对象。
2. 以该对象为上下文，执行构造函数，同时传递实参。
3. 判断执行构造函数返回的值:
  a. 如果是一个引用类型，就返回这个引用。
  b. 如果不是引用类型，返回创建的对象。
## 手写new
```js
// constructor: new的目标函数，也就是构造函数
function _new(constructor, ...args) {
  // 注意健壮性
  if (Object.prototype.toString.call(constructor) !== '[object Function]') {
    console.error('第一个参数请传入函数');
    return;
  }
	// 创建一个继承构造函数原型的对象，即将把它作为构造函数的执行背景。
  const context = Object.create(constructor.prototype);
  // 以该对象为this，执行构造函数
  // 构造函数往往会有this.name = name之类的语句，也就是说这一步在填充对象。
  const result = constructor.apply(context, args);
  // 如果有执行结果，返回执行结果；如果没有，返回该对象。
  return (typeof result === 'object' && result !== null) ? result : context;
}
```
### 手写以后的追问
1. 为什么不用 Object.setPrototypeOf 来修改原型？
mdn上介绍过，由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的原型在各个浏览器和 JavaScript 引擎上都是一个很慢的操作，如果开发者关心性能，应该避免设置一个对象的原型。相反，应该使用 Object.create() 来创建带有您想要的原型的新对象。
2. 为什么源码里有很多 const o = Object.create(null) ，不能直接 const o = {} 吗？
Object.create(null)可以创建一个纯净的对象，对象上没有从 Object.prototype 继承来的属性。


# f箭头函数
## 1.讲概念
箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this, arguments, super 还有 new.target。
箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。 (因为它没有 constructor，也就是构造器)
## 2.注意点
### 没有 this
箭头函数不会创建自己的`this`,它只会从自己的作用域链的上一层继承`this`。
由于箭头函数没有自己的`this`指针，通过 call 或 apply 方法调用一个函数时，第一个参数会被忽略，第二个往后的参数才会生效。
```js
function Person(){
  this.age = 0;
  setInterval(() => {
    this.age++; // |this| 正确地指向 p 实例
  }, 1000);
}
var p = new Person();
```
### 没有 arguments
### new 一个箭头函数会报错
箭头函数不能用作构造器，和 new一起用会抛出错误。 为啥？它没有 prototype，也就没有 constructor。
```js
var Foo = () => {};
var foo = new Foo(); // TypeError: Foo is not a constructor
```
### 没有 prototype
箭头函数没有prototype属性。
```js
var Foo = () => {};
console.log(Foo.prototype); // undefined
```

# f数据类型
JavaScript 语言中数据类型集合由原始值和对象组成。
## 原始值（直接表示在语言底层的不可变数据）
布尔类型
Null 类型
Undefined 类型
Number 类型
BigInt 类型
String 类型
Symbol 类型
## 对象（一组属性的集合）
函数、对象

# f判断数据类型
## 方法一: ftypeof
typeof 操作符返回一个字符串，表示操作数的类型。
### typeof 缺点
1. 对 Object/Array/Map/Set/Null 都是返回 "object"，无法进一步细分类型。
2. `typeof null` 是 "object"，让人疑惑，这是一个历史原因:
在 JavaScript 最初的实现中，JavaScript 中的`值`是用`表示类型的标签`和`实际数据值`表示的。它用一个`32bit`的数据存储，其中用了 `3个bit` 来存储类型，`对象`的类型是 `000`。而由于`null`代表的是空指针，值为`0x00`，所以 `null`的类型标签也是`000`，所以 `null` 也被认为是一个 `对象`，`typeof null` 也就返回 "object"。
## 方法二: Object.prototype.toString.call
这个比较准确。可以使用 Object.prototype.toString.call 做细分判断，它同样返回一个字符串，值为 "[object Constructor]"
## 方法三: finstanceof
instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
### instanceof 缺点
1. 如果表达式 obj instanceof Foo 返回 true，则并不意味着该表达式会永远返回 true，因为 Foo.prototype 属性的值有可能会改变，改变之后的值很有可能不存在于 obj 的原型链上，这时原表达式的值就会成为 false。
2. 另外一种情况下，原表达式的值也会改变，就是改变对象 obj 的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的 __proto__ 伪属性，是可以实现的。比如执行 obj.__proto__ = {} 之后，obj instanceof Foo 就会返回 false 了。
3. 在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 [] instanceof window.frames[0].Array 会返回 false，因为 Array.prototype !== window.frames[0].Array.prototype，并且数组从前者继承。
### instanceof 的坑爹题
instanceof 检查`右边这个构造函数的prototype`也就是原型，是否在`左边这个对象`的原型链上，是就返`true`，不是就返回`false`。
```js
// 目标:  检查 Function.prototype 是否在 Function 的原型链上。
// 思路:  把 Object 看成一个对象，它是由 Function 构造的，于是 Object.__proto__ === Function.prototype。
// 答案:  true;
Object instanceof Function  // true;

// 目标:  检查 Object.prototype 是否在 Function 的原型链上。
// 思路:  把 Function 看成一个对象，它是由 Function 构造的，于是 Function.__proto__ === Function.prototype，
//    然后 Function.prototype 是一个普通的对象，它是由 Object 构造的，所以 Function.prototype.__proto__ === Object.prototype。
//    所以 Function.__proto__.__proto___ === Object.prototype。
// 答案: true;
Function instanceof Object  // true;  
```


# ffor..in  遍历key
## 1.讲概念
`for...in`语句迭代一个对象的除`Symbol`以外的`可枚举属性`，包括`继承`的可枚举属性。
(
  1. 通过 `Object.prototype.hasOwnProperty` 只遍历自身属性
  2. Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
)
## 2.说用途
`for...in`是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用`Array.prototype.forEach`和`for...of`。
`for...in`最常用的地方应该是用于调试，可以更方便的去检查对象属性（通过输出到控制台或其他方式）。尽管对于处理存储数据，数组更实用些，但是你在处理有key-value数据（比如属性用作“键”），需要检查其中的任何键是否为某值的情况时，还是推荐用`for...in`。

# ffor..of  遍历value
## 1.讲概念
`for...of`语句在`可迭代对象`上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的`值`执行语句.
`可迭代对象`包括 Array，Map，Set，String，TypedArray，arguments 对象等。
```js
// 迭代map例子
const map = new Map([["a", 1], ["b", 2], ["c", 3]]);
for (const entry of map) {
  console.log(entry);
}
// ["a", 1]
// ["b", 2]
// ["c", 3]
```
## 2.说用途
实现迭代接口[Symbol.iterator]，自定义被迭代的数据。
```js
const iterable = {
  [Symbol.iterator]() {
    return {
      i: 0,
      next() {
        return  this.i < 3 ? { value: this.i++, done: false } : { value: undefined, done: true };
      }
    };
  }
};
for (const value of iterable) {
  console.log(value);
}
// 0
// 1
// 2
```

# ffor..in 和 for..of 的区别
无论是for...in还是for...of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。
1. 一个是 `key`，一个是 `value`。
* for...in 语句迭代对象除`Symbol`外的可`枚举属性`。
* for...of 语句遍历可迭代对象定义要迭代的数据。
2. 访问原型链
* `for..in` 会把从原型链上继承的`可枚举属性`也遍历出来
* `for..of` 是按对象`实现的/内置的`迭代接口来遍历，一般不会遍历到原型链上的值。

# fmap
## 1.讲概念
map 方法`创建一个新数组`，这个新数组由原数组中的`每个元素都调用一次提供的函数`后的返回值组成。
map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在`有值的索引`上被调用；那些`从来没被赋过值`或者`使用 delete 删除的索引`则不会被调用。
## 2.说用途
因为map`生成一个新数组`，当你不打算使用返回的新数组却使用map是违背设计初衷的，请用`forEach`或者`for-of`替代。
## 3.注意点
map 方法`处理数组元素的范围是在 callback 方法第一次调用之前就已经确定了`。调用map方法之后追加的数组元素`不会被callback访问`。如果存在的数组元素改变了，那么传给callback的值是map访问该元素时的值。在map函数调用后但在访问该元素前，该元素被删除的话，则无法被访问到。

# fforEach
## 1.讲概念
forEach 方法对数组的每个元素执行一次给定的函数。
forEach 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。
forEach 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。
已删除的项不会被遍历到，如果已访问的元素在迭代时被删除了，比如使用 shift，之后的元素将被跳过。
## 2.注意点
除了抛出异常以外，没有办法中止或跳出 forEach循环。如果你需要中止或跳出循环，forEach() 方法不是应当使用的工具。
若你需要提前终止循环，你可以使用：every/some/find/findIndex。
## 3.手写forEach
```js
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {

  Array.prototype.forEach = function(callback, thisArg) {

    var T, k;

    if (this == null) {
      throw new TypeError(' this is null or not defined');
    }

    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument "length".
    // 3. Let len be toUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If isCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== "function") {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}

```

# 如何跳出 map 或 forEach 循环
map 和 forEach 不能被中断: 一旦开始就不能 break，如果想中途跳出循环，可以在遍历的外层加一个 try...catch，然后中途 throw 一个 Error。
```js
const a = [1,2,3,4,5,6];
try {
  a.forEach(v => {
    if (v === 3) {
      throw new Error('break');
      // break;  // Uncaught SyntaxError: Illegal break statement
    }
    console.log(v);
  })
} catch(e) {
  console.error(e);
}
```

# f拷贝
拷贝对象分为两种情况，一种是`浅拷贝`，一种是`深拷贝`。
## 浅拷贝
`浅拷贝`指的是简单地将一个对象的属性值复制到另一个对象，如果有的属性的值为`引用`类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。
### 实现
浅拷贝可以使用 `Object.assign` 和 `展开语法` 来实现。
### 缺点
如果拷贝的是引用类型，拷贝之后的对象引用会影响到原始对象。
```js
const obj = {
  inObj: {a: 1, b: 2}
}
const clone = {...obj}   // 或  Object.assign({}, obj);
clone.inObj.a = 2;   // 原始对象也变了
console.log(obj) // {inObj: {a: 2, b: 2}}
```
## 深拷贝
为了解决`浅拷贝对象的引用影响原始对象`的问题，我们可以使用`深拷贝`的方式。
深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它`新建一个引用类型`并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引
用。
### 实现
1. 可以用 JSON 的两个 api: `JSON.parse(JSON.stringify())` 实现深拷贝，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。
```js
const o = { fn: function() {}, [Symbol.for('react')]: "我是Symbol值" };
const clone = JSON.parse(JSON.stringify(o));
console.log(clone);  // {}
```
2. 递归。针对 `JSON` 的问题，可以用 `递归` 实现深拷贝，具体的思路是:
遍历原始对象自身的属性，如果是原始类型直接复制，如果是引用类型，则递归地调用`深拷贝`函数，区分不同类型的对象进行处理，然后进行拷贝。
#### 简单版
```js
function deepCopy(object) {
  if (!object || typeof object !== "object") return object;

  const newObject = Array.isArray(object) ? [] : {};

  for (const key in object) {
    if (object.hasOwnProperty(key)) {
      newObject[key] =
        typeof object[key] === "object" ? deepCopy(object[key]) : object[key];
    }
  }

  return newObject;
}
```
#### 全面版
拷贝对象的所有属性
遍历属性，根据属性值:
1. 对象: 递归(根据构造函数，新建不同对象、处理，返回)
2. 非对象: 拷贝原对象的属性值
```js
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}

function cloneDeep(data, hash = new WeakMap()) {
  if (!isObject(data) || !data || !data.constructor) {
    return data
  }
  let copyData   // 存储各种类型的对象
  const Constructor = data.constructor
  switch (Constructor) {
    case RegExp:
      // 正则表达式: 用原数据新建一个正则对象  new RegExp(...原正则数据) 
      copyData = new Constructor(data)
      break
    case Date:
      // Date: 用时间戳新建一个 Date 对象
      copyData = new Constructor(data.getTime())
      break
    default:
      // 解决循环引用  (obj.circle = obj)
      // 如果遇到过这个引用，返回之前拷贝好的引用s
      // 最原始对象的引用，也在 hash 里
      if (hash.has(data)) {
        return hash.get(data)
      }
      copyData = new Constructor()
      if (Constructor === Map) {
        data.forEach((value, key) => {
          // 原始 Map 的元素，一个一个加入到 拷贝的 Map 中
          copyData.set(key, isObject(value) ? cloneDeep(value) : value)
        })
      }
      if (Constructor === Set) {
        data.forEach(value => {
          // 原始 Set 的元素，一个一个加入到 拷贝的 Set 中
          copyData.add(isObject(value) ? cloneDeep(value) : value)
        })
      }
      // 拷贝过的引用都记录一下
      // WeakMap弱引用，不计入GC的引用中，不干扰垃圾回收的判断
      hash.set(data, copyData)
  }

  // 解决 for..in 不能遍历 Symbol 属性的问题
  const symbols = Object.getOwnPropertySymbols(data)
  if (symbols && symbols.length) {
    symbols.forEach(symkey => {
      copyData[symkey] = isObject(data[symkey]) ? cloneDeep(data[symkey], hash) : data[symkey]
    })
  }
  // 遍历基本属性
  for (var key in data) {
    copyData[key] = isObject(data[key]) ? cloneDeep(data[key], hash) : data[key]
  }
  // 拷贝完成✅
  return copyData
}
```

# f==
## 1.讲概念
等于运算符（==）检查其两个操作数是否相等，并返回Boolean结果。与严格相等运算符（===）不同，它会尝试强制类型转换并且比较不同类型的操作数。
## 2.说实现
根据 ECMA-262规范，相等运算符（`==`和`!=`）使用`抽象相等比较算法`比较两个操作数。
概括如下:
1. 如果两个操作数`都是对象`，则仅当两个操作数都`引用同一个对象`时才返回`true`。
2. 如果一个操作数是`null`，另一个操作数是`undefined`，则返回`true`。
3. 如果两个操作数是`不同类型的`，就会尝试在比较之前将它们转换为`相同类型`：
  * 当数字与字符串进行比较时，会尝试将字符串转换为数字值。
  * 如果操作数之一是`Boolean`，则将布尔操作数转换为`1`或`0`。如果是true，则转换为1。如果是 false，则转换为0。
  * 如果操作数之一是`对象`，另一个是`数字或字符串`，会先尝试使用对象的`valueOf`方法, 再尝试使用`toString`方法，将对象转换为`原始值`。
4. 如果操作数具有`相同的类型`，则将它们进行如下比较：
  * String：true仅当两个操作数具有相同顺序的相同字符时才返回。
  * Number：true仅当两个操作数具有相同的值时才返回。`+0`和`-0`视为相同的值。如果任一操作数为`NaN`，则返回`false`。
  * Boolean：true仅当操作数为两个true或两个false时才返回true。
## 3.和 全等 的区别
此运算符与严格等于（===）运算符之间最显着的区别在于，严格等于运算符`不尝试类型转换`。严格相等运算符始终`将不同类型的操作数视为不同`。
## 4.例子
```js
// 隐式类型转换
1 == "1";             // true, String转为数字
0 == false;           // true, Boolean转为数字
0 == null;            // false, null 不能转为原始类型
0 == undefined;       // false, undefined 不能转为原始类型
null == undefined;    // true, null和undefined隐式类型转换后相等
// 对象和原始值
const obj = new Number(3);  // 对象
obj == 3;         // true，因为 obj.valueOf() === 3
[] == '';         // true，因为([]).valueOf()是[]，不是原始值，然后([]).toString()是''
'[object Object]' == {};  // true，因为 ({}).valueOf()是{}不是原始值，然后({}).toString()是'[object Object]'
const o = { valueOf: () => '1', toString: () => '2' };
o == '1';  // true，valueOf返回'1'
o == 1;    // true，valueOf返回'1'，'1'转化为1
// 对象比较
const object1 = {"key": "value"}
const object2 = {"key": "value"};
object1 == object2 // false
object2 == object2 // true
// 比较字符串和String对象
const string1 = "hello";
const string2 = String("hello");
const string3 = new String("hello");
const string4 = new String("hello");
console.log(string1 == string2); // true
console.log(string1 == string3); // true
console.log(string2 == string3); // true
console.log(string3 == string4); // false
console.log(string4 == string4); // true
// 比较日期和字符串
const d = new Date('December 17, 1995 03:24:00');
const s = d.toString(); // for example: "Sun Dec 17 1995 03:24:00 GMT-0800 (Pacific Standard Time)"
console.log(d == s);    //true
```

# f===
## 1.讲概念
全等运算符`===`会检查它的两个操作数是否相等，并且返回一个布尔值结果。与相等运算符`==`不同，全等运算符总是认为`不同类型的操作数是不同的`。
## 2.说实现
全等运算符（===和 !==）使用全等比较算法来比较两个操作数。
1. 如果操作数的类型不同，则返回 false。
2. 如果两个操作数都是对象，只有当它们指向同一个对象时才返回 true。
3. 如果两个操作数都为 null，或者两个操作数都为 undefined，返回 true。
4. 如果两个操作数有任意一个为 NaN，返回 false。
5. 否则，比较两个操作数的值：
  * 数字类型必须拥有相同的数值。+0 和 -0 会被认为是相同的值。
  * 字符串类型必须拥有相同顺序的相同字符。
  * 布尔运算符必须同时为 true 或同时为 false。
## 3.和相等运算符的区别
全等运算符`===`和相等运算符`==`最显著的区别: 如果操作数的`类型不同`，相等运算符会在比较之前`尝试将它们转换为相同的类型`。
### 4.一些很特殊的例子
```js
NaN === NaN;  // false (NaN这家伙急眼了连自己都不认识)
+0 === -0;    // true  (全等认为正负零是一样的)
```

# fObject.is
## 1.讲概念
Object.is() 方法判断两个值是否为同一个值。
## 2.说用途
`Object.is`与全等运算符`===`不相同。差别是它们对待`有符号的零`和`NaN`不同。
全等运算符`===`将数字`-0`和`+0`视为`相等`，而将`NaN`与`NaN` 视为不相等。`Object.is`刚好相反。
## 3.说实现
Object.is() 方法判断两个值是否为同一个值，如果满足以下任意条件则两个值相等：
1. 都是 undefined
2. 都是 null
3. 都是 true 或都是 false
4. 都是相同长度、相同字符、按相同顺序排列的字符串
5. 都是相同对象（意味着都是同一个对象的值引用）
6. 都是数字且
  * 都是 +0
  * 都是 -0
  * 都是 NaN
  * 都是同一个值，非零且都不是 NaN
## 4.例子
```js
// 有符号的0
Object.is(+0, -0);    // false
Object.is(0, -0);     // false
Object.is(-0, -0);    // true
Object.is(0n, -0n);   // true
// NaN
Object.is(NaN, NaN)    // true
Object.is(NaN, 0/0);   // true
```
## 4.polyfill
```js
if (!Object.is) {
  Object.defineProperty(Object, "is", {
    value: function (x, y) {
      if (x === y) {
        // 同类型并且同值
        // true: ”不等于0“ 或 "等于0但必须相同符号“
        return x !== 0 || 1 / x === 1 / y;
      } else {
        // 不同类型或不同值
        // 返回true:  x,y 都是 NaN  (Number.NaN, 0/0, NaN)
        // 返回false: 剩余所有情况
        return x !== x && y !== y;
      }
    }
  });
}
```

# f模块化
## 1.讲概念
JS 模块分为 `用于服务端的模块` 和 `用于浏览器的模块`，在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。
### 用于服务端的模块  CommonJS
`CommonJS`以`require`为输入，以`module.exports`为输出，它是`运行时`加载的，输出的是`对模块的拷贝`，这意味着两点:
1. 它不能 Tree-Shaking
2. 一旦输出一个值，模块内部的变化就影响不到这个输出值了
```js
var mod = require('./lib');
console.log(mod.counter);  // 3
mod.incCounter();  // 模块lib内部增加了count
console.log(mod.counter); // 3  不变
```
服务器端所有的模块都存放在`本地硬盘`，可以`同步加载完成`，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于`假死`状态。
### 用于浏览器的模块 AMD(实现AMD规范的require.js)   CMD(实现CMD规范的sea.js，define语法，了解即可)
社区制定了`AMD`规范，`AMD`是`Asynchronous Module Definition`的缩写，意思就是`异步模块定义`。

它采用异步方式加载模块，模块的加载`不影响它后面语句的运行`。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。

`AMD`使用`define`定义模块，`require`加载模块。加载模块时要求两个参数，第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。
```js
// 定义模块 math
define(function () {
  var add = function (x, y) {
    return x + y;
  };
  return {
    add: add
  };
});
// 使用模块 math
require(['math'], function (math){
　alert(math.add(1,1));
});
```
在`AMD`中，`依赖模块的代码在回调中执行`，所以`模块加载`不会阻塞后续代码，浏览器不会发生`假死`。所以，AMD比较适合浏览器环境。

### 既可以用在浏览器端，也可以用在服务端 ESM  UMD(IIFE，了解即可)
#### ESM
ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
`ESM`以`import`为输入，以`export`为输出。
`ESM`是对模块的`引⽤`，即`ESM`只读，不能改变其值，也就是指针指向不能变，类似`const`。
`ESM``编译时`就能确定模块的依赖关系，以及输入和输出的变量。而`CommonJS`和`AMD`模块，都只能在`运行时`确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。由于 ES6 模块是编译时加载，使得静态分析成为可能，所以能使用 Tree-Shaking 进行摇树优化。

## 2. CommonJS 和 ESM 的异同
同: `CommonJS`和`ESM`都可以对引⼊的对象的属性进⾏赋值，即对对象内部属性的值进⾏改变。

异: 它们有三个重大差异:
1. CommonJS 模块输出的是一个值的拷贝，可以改变；ES6 模块输出的是值的引用，是只读的，不能改变。
2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
3. CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。


============================================== f浏览器 ==============================================
# f重排(也就是f回流)  尺寸变了
## 讲概念
当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为`回流`。
### 导致`回流`的操作
- 页面的首次渲染
- 浏览器的窗口大小发生变化
- 元素的内容发生变化
- 元素的尺寸或者位置发生变化
- 元素的字体大小发生变化
- 激活CSS伪类
- 查询某些属性或者调用某些方法
- 添加或者删除可见的DOM元素

在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：
- 全局范围：从根节点开始，对整个渲染树进行重新布局
- 局部范围：对渲染树的某部分或者一个渲染对象进行重新布局

# f重绘    颜色变了
## 讲概念
当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是`重绘`。
### 导致`重绘`的操作
- color、background 相关属性：background-color、background-image 等
- outline 相关属性：outline-color、outline-width 、text-decoration
- border-radius、visibility、box-shadow

注意： **当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。**

# f避免回流与重绘
- 操作DOM时，尽量在低层级的DOM节点进行操作
- 不要使用`table`布局， 一个小的改动可能会使整个`table`进行重新布局
- 使用CSS的表达式
- 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
- 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素
- 避免频繁操作DOM，可以创建一个文档片段`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中
- 将元素先设置`display: none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
- 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于`浏览器的渲染队列机制`。浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。


# f事件机制
## 1.讲概念
DOM的事件机制分为`事件捕获`和`事件冒泡`。
当一个事件发生在`具有父元素的元素`上时，现代浏览器运行两个不同的阶段-捕获阶段和冒泡阶段。 
### f捕获
浏览器检查元素的最外层祖先<html>，是否在捕获阶段中注册了一个事件处理程序，如果是，则运行它。
然后，它移动到<html>中`触发事件的元素`的下一个`祖先元素`，并执行相同的操作，然后是`触发事件的元素`再下一个祖先元素，依此类推，直到到达`触发事件的元素`。
### f冒泡
浏览器检查实际点击的元素是否在`冒泡阶段`中注册了一个`事件处理程序`，如果是，则运行它。
然后它移动到下一个`直接的祖先元素`，并做同样的事情，然后是下一个，等等，直到它到达<html>元素。

在现代浏览器中，默认情况下，所有事件处理程序都在`冒泡阶段`进行注册，如果想在`捕获阶段`注册，可以通过 addEventListener 注册事件处理程序，同时把可选的第三个参数设置为 true。
## 2.怎么停止冒泡
`标准事件对象`具有可用的名为`stopPropagation`的函数, 当在事件对象上调用该函数时，它只会让`当前事件处理程序运行`，但事件不会在冒泡链上进一步扩大，因此将不会有更多事件处理器被运行，也就是不会向上冒泡。
## 3.面试题
在一个DOM上绑定两个点击事件，一个冒泡，一个捕获，事件会执行几次？顺序如何？
答: `2次`。先执行捕获的事件处理程序，再执行冒泡的事件处理程序。


# f事件委托
## 1.讲概念
浏览器的`事件冒泡`机制允许我们利用`事件委托`: 如果你想要在大量子元素中单击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并让子节点上发生的事件冒泡到父节点上，而不是每个子节点单独设置事件监听器。
## 2.说用途
比如有一系列的列表项，如果想让每个列表项被点击时弹出一条信息，您可以将click单击事件监听器设置在父元素<ul>上，这样事件就会从列表项冒泡到其父元素<ul>上。
```html
<body>
  <ul id="parent-list">
    <li id="post-1">Item 1</li>
    <li id="post-2">Item 2</li>
    <li id="post-3">Item 3</li>
  </ul>
  <script>
    // 获取 ul，注册事件处理程序
    document.getElementById("parent-list").addEventListener("click", function (e) {
      // e.currentTarget 是"注册了事件处理程序的元素"，也就是 ul
      if (e.target && e.target.nodeName == "LI") {
        // e.target 是"实际点击的元素"，进入这个条件的，就是 li
        // 打印 li 的  id
        console.log("List item ", e.target.id.replace("post-", ""), " was clicked!");  // List item 1 was clicked!
      }
    });
  </script>
</body>
```
## 3.为什么要用 事件委托？
在日常开发中，li 经常是要从列表中添加和删除的。如果不用`事件委托`，直接把事件处理程序绑定在 li 上的话，每次 li 增加就要绑一次事件处理程序，每次 li 删除又要解绑一次事件处理程序，这样会增加`开发`和`维护`工程的负担，也容易出问题(比如，在 IE6 中不解绑事件处理程序就删除 DOM 的话，会造成内存泄漏)，而用`事件委托`就能很好地解决这些问题。


# f事件循环 浏览器
## 1.讲概念
在浏览器中，一个 JavaScript 运行时包含了一个待处理消息的`消息队列`。每一个消息都关联着一个用以处理这个消息的回调函数。
在`事件循环`期间的某个时刻，`运行时`会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来`调用与之关联的函数`，函数的处理会一直进行到执行栈为空为止；然后如果`队列`中还有消息，`事件循环`将会处理下一个消息。
## 2.说用途
### 处理DOM事件回调
在浏览器里，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列。如果没有事件监听器，这个事件将会丢失。所以当一个带有点击事件处理器的元素被点击时，就会像其他事件一样产生一个类似的消息。
### 处理 setTimeout 等
函数 setTimeout 接受两个参数：待加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。
## 3.优缺点
### 优点
每一个消息完整地执行后，其它消息才会被执行。这为程序的分析提供了一些优秀的特性，包括: 当一个函数执行时，它不会被抢占，只有在它运行完毕之后才会去运行任何其他的代码，才能修改这个函数操作的数据。
### 缺点
这个模型的一个缺点在于当一个消息需要`太长时间`才能处理完毕时，Web应用程序就`无法处理与用户的交互`，例如点击或滚动。为了缓解这个问题，一个良好的习惯是缩短单个消息处理时间，并在可能的情况下将一个消息裁剪成多个消息。
## 4.扩展
### 浏览器一帧中执行 JS 的全部时机
一个task(宏任务) -- 队列中全部job(微任务) -- requestAnimationFrame -- 浏览器重排/重绘 -- requestIdleCallback

requestAnimationFrame 既不是宏任务，也不是微任务，它在微任务之后执行，是浏览器在一帧的时间中，一定会经历的一个阶段。
```js
// 先打印 micro task, 再打印 request animation frame。
// 先放的 rAF 再放的微任务， 结果微任务先打印了，说明 requestAnimationFrame 在微任务之后执行。
setTimeout(() => {
    requestAnimationFrame(() => {
        console.log('request animation frame');
    })
    Promise.resolve(1).then(() => {
        console.log('micro task');
    })
}, 500)
```
```js
// 先打印 request animation frame, 再打印 宏任务
// 先放的宏任务再放的 rAF，结果 rAF 先执行了，说明 request animation frame 不是宏任务
setTimeout(() => {
    setTimeout(() => {
        console.log('宏任务')
    })
    requestAnimationFrame(() => {
        console.log('request animation frame');
    })
}, 500)
```

# f缓存
## 1.讲概念
缓存分为`强缓存`和`协商缓存`。
- 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
- 下一次加载资源时，由于强制缓存优先级较高，先比较`当前时间`与上一次返回 200 时的`时间差`，如果没有超过`Cache-Control`设置的`max-age`(相对过期时间)则没有过期，并命中`强缓存`，直接`从本地读取资源`。如果浏览器不支持HTTP1.1，则使用`Expires`头(一个绝对时间)判断是否过期；
- 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
- 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
- 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；
## 2.说实现
### 怎么设置强缓存  (不需要请求，直接200)
强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。
#### Expires
服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。
#### Cache-Control
Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，`Cache-Control`可设置的字段：
- `public`：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；
- `private`：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；
- `no-cache`：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；
- `no-store`：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；
- `max-age=`：设置缓存的最大有效期，单位为秒；
- `s-maxage=`：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；
- `max-stale[=]`：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。
一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。
### 怎么设置协商缓存  (需要请求，返回304就使用缓存)
协商缓存也可以通过两种方式来设置，分别是 http 头信息中的`Last-Modified`和`Etag`属性。
#### Last-Modified
服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 `If-Modified-Since` 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。
#### Etag
（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 `If-None-Match` 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。
当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。
### 总结
强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。
#### no-cache和no-store很容易混淆
- no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；
- no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。
#### 流程结构
1. 无缓存
向服务器发起请求;
2. 有缓存
在有缓存的情况下，检查缓存是否过期;
  * 没有过期  (强缓存)
  读取本地缓存，返回;
  * 已经过期  (协商缓存)
  查看缓存的头部中是否有 E-tag;
    * 有 E-tag
    发起 HTTP 请求，头部中携带 If-None-Match，返回304则使用缓存，返回200则用新的数据同时更新 E-tag;
    * 没有 E-tag
    检查是否有 Last-Modified
      * 有
      发起 HTTP 请求，头部中携带 If-Modified-Since，返回304则使用缓存，返回200则用新的数据同时更新Last-Modified;
      * 没有
      发起 HTTP 请求，返回响应，缓存协商。

# f缓存的位置
## 1.讲概念
资源缓存的位置一共有 3 种，按优先级从高到低分别是:
## Service Worker
Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们`自由控制`缓存哪些文件、如何匹配缓存、如何读取缓存，并且`缓存是持续性的`。当 Service Worker 没有命中缓存的时候，需要去调用 `fetch` 函数获取 数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。
## Memory Cache
Memory Cache 就是内存缓存，它的效率最快，但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
## Disk Cache
Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache`胜在容量和存储时效性上`。在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。**并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。
  ### Disk Cache 的 Push Cache (这个可以不说)
  Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：
  - 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
  - 可以推送 `no-cache` 和 `no-store` 的资源
  - 一旦连接被关闭，Push Cache 就被释放
  - 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
  - Push Cache 中的缓存只能被使用一次
  - 浏览器可以拒绝接受已经存在的资源推送
  - 可以给其他域名推送资源

# fService Worker
## 1.讲概念
1. Service Worker 可以使你的应用先访问本地缓存资源，所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能（一般称之为 Offline First）。这是原生APP 本来就支持的功能，这也是相比于 web app，原生 app 更受青睐的主要原因。
2. 你的 service worker 函数像一个代理服务器一样，允许你修改请求和响应，用他们的缓存替代它们等等。
3. 你需要通过 HTTPS 来访问你的页面 — 出于安全原因，Service Workers 要求必须在 HTTPS 下才能运行。为了便于本地开发，localhost 也被浏览器认为是安全源。
## 2.如何使用
通常遵循以下基本步骤来使用 service workers：
1. service worker URL 通过 serviceWorkerContainer.register() 来获取和注册。
2. 如果注册成功，service worker 就在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊类型的 worker 上下文运行环境，与主运行线程（执行脚本）相独立，同时也没有访问 DOM 的能力。
3. service worker 现在可以处理事件了。
4. 受 service worker 控制的页面打开后会尝试去安装 service worker。最先发送给 service worker 的事件是安装事件(在这个事件里可以开始进行填充 IndexDB和缓存站点资源)。这个流程同原生 APP 或者 Firefox OS APP 是一样的 — 让所有资源可离线访问。
5. 当 oninstall 事件的处理程序执行完毕后，可以认为 service worker 安装完成了。
6. 下一步是激活。当 service worker 安装完成后，会接收到一个激活事件(activate event)。 onactivate 主要用途是清理先前版本的 service worker 脚本中使用的资源。
7. Service Worker 现在可以控制页面了，但仅是在 register()  成功后的打开的页面。也就是说，页面起始于有没有 service worker ，且在页面的接下来生命周期内维持这个状态。所以，页面不得不重新加载以让 service worker 获得完全的控制。
## 3.例子
### 3-1. 注册
```js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw-test/sw.js', { scope: '/sw-test/' }).then(function(reg) {
    // registration worked
    console.log('Registration succeeded. Scope is ' + reg.scope);
  }).catch(function(error) {
    // registration failed
    console.log('Registration failed with ' + error);
  });
}
```
1. 外面的代码块做了一个特性检查，在注册之前确保 service worker 是支持的。
2. 接着，我们使用 ServiceWorkerContainer.register() 函数来注册站点的 service worker，service worker 只是一个驻留在我们的 app 内的一个 JavaScript 文件 (注意，这个文件的url 是相对于 origin， 而不是相对于引用它的那个 JS 文件)。
3. scope 参数是选填的，可以被用来指定你想让 service worker 控制的内容的子目录。在这个例子里，我们指定了 '/sw-test/'，表示 app 的 origin 下的所有内容。如果你留空的话，默认值也是这个值， 我们在指定只是作为例子。
4. .then() 函数链式调用我们的 promise，当 promise resolve 的时候，里面的代码就会执行。
5. 最后面我们链了一个 .catch() 函数，当 promise rejected 才会执行。

这就注册了一个 service worker，它工作在 worker context，所以没有访问 DOM 的权限。在正常的页面之外运行 service worker 的代码来控制它们的加载。
单个 service worker 可以控制很多页面。每个你的 scope 里的页面加载完的时候，安装在页面的 service worker 可以控制它。牢记你需要小心 service worker 脚本里的全局变量： 每个页面不会有自己独有的worker。
关于 service workers 一个很棒的事情就是，如果你用像上面一样的浏览器特性检测方式检测发现浏览器并不支持SW，你还是可以正常地在线使用页面。与此同时，如果你在一个页面上同时使用 AppCache 和 SW , 不支持 SW 但是支持 AppCache  的浏览器，可以使用 AppCache，如果都支持的话，则会采用 SW。

### 3-2. 安装和激活：填充你的缓存
在你的 service worker 注册之后，浏览器会尝试为你的页面或站点安装并激活它。 
install 事件会在注册完成之后触发。install 事件一般是被用来填充你的浏览器的离线缓存能力。为了达成这个目的，我们使用了 Service Worker 的新的标志性的存储 API — cache — 一个 service worker 上的全局对象，它使我们可以存储网络响应发来的资源，并且根据它们的请求来生成key。这个 API 和浏览器的标准的缓存工作原理很相似，但是是特定你的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。
```js
this.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open('v1').then(function(cache) {
      return cache.addAll([
        '/sw-test/',
        '/sw-test/index.html',
        '/sw-test/style.css',
        '/sw-test/app.js',
        '/sw-test/image-list.js',
        '/sw-test/star-wars-logo.jpg',
        '/sw-test/gallery/',
        '/sw-test/gallery/bountyHunters.jpg',
        '/sw-test/gallery/myLittleVader.jpg',
        '/sw-test/gallery/snowTroopers.jpg'
      ]);
    })
  );
});
```
1. 这里我们 新增了一个 install 事件监听器，接着在事件上接了一个ExtendableEvent.waitUntil()  方法——这会确保Service Worker 不会在 waitUntil() 里面的代码执行完毕之前安装完成。
2. 在 waitUntil() 内，我们使用了 caches.open() 方法来创建了一个叫做 v1 的新的缓存，将会是我们的站点资源缓存的第一个版本。它返回了一个创建缓存的 promise，当它 resolved 的时候，我们接着会调用在创建的缓存示例上的一个方法  addAll()，这个方法的参数是一个由一组相对于 origin 的 URL 组成的数组，这些 URL 就是你想缓存的资源的列表。
3. 如果 promise 被 rejected，安装就会失败，这个 worker 不会做任何事情。这也是可以的，因为你可以修复你的代码，在下次注册发生的时候，又可以进行尝试。
4. 当安装成功完成之后， service worker 就会激活。在第一次你的 service worker 注册／激活时，这并不会有什么不同。但是当  service worker 更新 (稍后查看 更新你的 service worker 部分) 的时候 ，就不太一样了。

### 3-3. 自定义请求的响应
现在你已经将你的站点资源缓存了，你需要告诉 service worker 让它用这些缓存内容来做点什么。有了 fetch 事件，这是很容易做到的。

每次任何被 service worker 控制的资源被请求到时，都会触发 fetch 事件，这些资源包括了指定的 scope 内的文档，和这些文档内引用的其他任何资源（比如 index.html 发起了一个跨域的请求来嵌入一个图片，这个也会通过 service worker 。）

你可以给 service worker 添加一个 fetch 的事件监听器，接着调用 event 上的 respondWith() 方法来劫持我们的 HTTP 响应，然后你用可以用自己的方法来更新他们。

下面的例子是: 在任何情况下我们只是简单的响应这些缓存中的 url  和网络请求匹配的资源。
```js
this.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.match(event.request)
  );
});
```
caches.match(event.request) 允许我们对网络请求的资源和 cache 里可获取的资源进行匹配，查看是否缓存中有相应的资源。这个匹配通过 url 和 vary header进行，就像正常的 http 请求一样。

在响应时可以有更多的选项:
1. 你可以在你的响应里选择性的传一系列 header，来模仿标准的 HTTP 响应 header。这里我们只告诉浏览器我们虚假的响应的 content type：
```js
new Response('<p>Hello from your friendly neighbourhood service worker!</p>', {
  headers: { 'Content-Type': 'text/html' }
})
```
2. 如果没有在缓存中找到匹配的资源，你可以告诉浏览器对着资源直接去 fetch 默认的网络请求:
```js
fetch(event.request)
```
3. 如果没有在缓存中找到匹配的资源，同时网络也不可用，你可以用 match() 把一些回退的页面作为响应来匹配这些资源，比如：
```js
caches.match('/fallback.html');
```
4. 你可以通过 FetchEvent 返回的 Request 对象检索到非常多有关请求的信息：
```js
event.request.url
event.request.method
event.request.headers
event.request.body
```


# fCookie
## 1.讲概念
HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的HTTP协议记录稳定的状态信息成为了可能。
## 2.说用途
Cookie 主要用于以下三个方面:
1. 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
2. 个性化设置（如用户自定义设置、主题等）
3. 浏览器行为跟踪（如跟踪分析用户行为等）
## 3.优缺点
Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 。
## 4.扩展
### 设置Cookie  (Set-Cookie/Cookie)
当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 Set-Cookie 选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过  Cookie 请求头部将 Cookie 信息发送给服务器。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。
#### HTTP 响应头
```java
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: <Cookie1的名称>=<Cookie1的值>
Set-Cookie: <Cookie2的名称>=<Cookie2的值>
```
现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过 Cookie 请求头部再发送给服务器。
#### HTTP 请求头
```java
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```
### 设置Cookie的有效期  (Expires/Max-Age 过期时间)
Cookie 的生命周期可以通过`两种方式`定义:
1. `会话期Cookie` 是最简单的 Cookie: 浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。
```java
Set-Cookie: id=a3fWa;  // 无需指定 Expires 或 Max-Age;
```
2. `持久性Cookie` 的生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。
```java
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```
### 限制访问Cookie  (限制 HTTP/JS 访问)
有两种方法可以确保 Cookie 被安全发送，并且不会被意外的参与者或脚本访问：Secure 属性和HttpOnly 属性。
#### Secure
标记为 Secure 的 Cookie 只应通过被`HTTPS`协议加密过的请求发送给服务端。但即便设置了`Secure`标记，敏感信息也不应该通过`Cookie`传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。
#### HttpOnly
JavaScript Document.cookie API 无法访问带有 HttpOnly 属性的cookie；此类 Cookie 仅作用于服务器。例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 HttpOnly 属性。此预防措施有助于缓解跨站点脚本攻击`XSS, 通过 JS 盗取 Cookie`。
```java
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```
### Cookie的作用域 (Domain/Path/SameSite, Cookie跨域)
Domain 和 Path 标识定义了Cookie的作用域：即允`Cookie`应该发送给哪些`URL`。
#### Domain (子域名可收Cookie)
`Domain`指定了哪些主机可以接受`Cookie`。
* 如果不指定，默认为`origin``不包含子域名`。
* 如果指定了Domain，则一般包含`子域名`。
因此，指定 Domain 比省略它的限制要少。但是，当子域需要共享有关用户的信息时，这可能会有所帮助。 例如，如果设置`Domain=mozilla.org`，则 Cookie 也包含在子域名中（如`developer.mozilla.org`）。
##### Cookie可以跨域吗？ 
可以，设置 Domain，想给哪些域就写哪些。
#### Path
`Path`标识指定了主机下的哪些`路径`可以接受`Cookie`（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F ("/") 作为路径分隔符，子路径也会被匹配。
例如，设置 Path=/docs，则以下地址都会匹配：
/docs
/docs/Web/
/docs/Web/HTTP
#### SameSite 跨域
`SameSite Cookie`允许服务器要求某个`cookie`在`跨站请求`时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。
```java
Set-Cookie: key=value; SameSite=Strict
```
##### 使用 SameSite
SameSite 可以有下面三种值:
1. None。浏览器会在同站请求、跨站请求下继续发送 cookies，不区分大小写。
2. Strict。浏览器将只在访问相同站点时发送 cookie。（在原有 Cookies 的限制条件上的加强，如上文 “Cookie 的作用域” 所述）
3. Lax。与 Strict 类似，但用户从外部站点导航至URL时（例如通过链接）除外。 在新版本浏览器中，为默认选项，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者 frames 的调用，但只有当用户从外部站点导航到URL时才会发送。如 link 链接


# flocalStorage
1. `localStorage`为每一个给定的源（given origin）维持一个独立的存储区域。
2. `localStorage` 中的键值对总是以字符串的形式存储。
3. 在浏览器关闭，然后重新打开，`localStorage`数据仍然存在。
## 和 sessionStorage 的异同
### 异
1. 存储在 localStorage 的数据可以长期保留；而对 sessionStorage 来说，当页面会话结束 —— 也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除 。
2. 同源的标签页, localStorage 可以共享数据，而 sessionStorage 不行。
### 同
跨域的标签页之间，无论 localStorage 还是 SessionStorage， 都是不能共享数据的。

# fsessionStorage
sessionStorage 属性允许你访问一个，对应当前源的 session Storage 对象。
## 用途
1. 页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。
2. 在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，这点和 session cookies 的运行方式不同。
3. 打开多个标签页面，会创建各自的 sessionStorage。
4. 关闭对应浏览器标签或窗口，会清除对应的 sessionStorage。 
## 和 localStorage 的区别
它与 localStorage 相似，不同之处在于 localStorage 里面存储的数据没有过期时间设置，而存储在 sessionStorage 里面的数据在页面会话结束时会被清除。


# f跨域资源共享
`跨源资源共享`是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其它 origin（域，协议和端口），使得浏览器允许这些 origin 访问加载自己的资源。

跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的`预检请求`。在预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头。

跨源资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME类型 的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。

## f简单请求
某些请求不会触发`CORS预检请求`，这样的请求被称为`简单请求`，`简单请求`应满足下列`所有条件`:
1. GET、HEAD、POST
2. 头部字段有范围限制，不能是`被用户代理自动设置`的字段，还有`fetch`规范定义的禁用字段
3. Content-Type 只能是 `text/plain`, `multipart/form-data`, `application/x-www-form-urlencode`

## f预检请求 (复杂请求)
## 1.讲概念
`预检请求`用于获取目的资源所`支持`的`通信选项`，一般用于检查服务器是否支持 CORS 即`跨域资源共享`。

它使用 HTTP 请求的`OPTIONS`方法，在`Headers`中携带 `Access-Control-Request-Method`, `Access-Control-Request-Headers`，以及一个`Origin`字段。

当有必要的时候，浏览器会`自动`发出一个预检请求；所以在正常情况下，前端开发者不需要自己去发这样的请求。

在对 `预检请求(OPTIONS)` 的应答中，`服务器`明确了`客户端`所要访问的资源允许使用的`源、方法、头部字段`等。
Access-Control-Allow-Origin 源
Access-Control-Allow-Methods 方法
Access-Control-Allow-Headers 头部字段
如果请求不满足 Acces-Control-Allow-*，响应报文将被浏览器拦截，并向页面抛出`CORS请求失败`的错误。

## 2.f干掉预检请求  (预检请求消耗了一定的性能，可能会影响用户体验)
1. 把`复杂请求`改为`简单请求`。
* 请求方法限制在 `GET`, `HEAD`, `POST`
* 去掉冗余的 `Headers`
* POST 的 body 改为 `text/plain` 等
2. 设置`Access-Control-Max-Age`，单位是秒
### Access-Control-Max-Age
The Access-Control-Max-Age 这个响应头表示`预检请求`的返回结果（即 Access-Control-Allow-Methods 和Access-Control-Allow-Headers 提供的信息） 可以被缓存多久。也就是告诉浏览器，在缓存期内，不要发出同样的预检请求。
#### 遇到的坑
Access-Control-Max-Age 必须写纯数字的字符串，后端用 java 很容易写出 long 类型的如 "18000L" 的值，这种浏览器是不识别的，应该改为 "18000"。
#### <delta-seconds>
返回结果可以被缓存的最长时间（秒）。
在 Firefox 中，上限是24小时 （即 86400 秒）。
在 Chromium v76 之前， 上限是 10 分钟（即 600 秒)。
从 Chromium v76 开始，上限是 2 小时（即 7200 秒)。
Chromium 同时规定了一个默认值 5 秒。
如果值为 -1，表示禁用缓存，则每次请求前都需要使用 OPTIONS 预检请求。


# fHTTPS
HTTPS`(安全的HTTP)`是 HTTP 协议的加密版本。它通常使用`SSL`或者`TLS`来加密客户端和服务器之间所有的通信 。这安全的链接允许客户端与服务器安全地交换敏感的数据，例如网上银行或者在线商城等涉及金钱的操作。
TLS: Transport Layer Security，传输层安全协议，由 SSL 发展而来。
## f加密过程
`TLS1.2握手`的`握手过程`是: 

1. 客户端生成一个`随机数`，然后把 `这个随机数` 和 一个 `密码套件列表` 发送给服务端; (密码套件: ECDHE密钥交换+RSA计算公私钥+AES128对称加密+GCM分组模式+SHA256摘要算法)
2. 服务端也生成一个随机数，然后从`密码套机列表`中选择一个 `密码套件`, 然后根据里面的算法，生成公私钥, 将 随机数、`密码套件`, `公钥` 和 `证书` 一起发给 客户端;
3. 客户端验证 `证书`, 通过后根据收到的`密码套件`计算自己的`公私钥`，然后把`自己的公钥`发给`服务器`，
接下来，用`服务器公钥`、`自己的私钥`、`服务端的随机数`、`客户端的随机数`，生成`对称密钥`。
(
  客户端拿到证书后如何证实? 
    证书里有 `服务器信息+公钥+CA机构签名的摘要`，CA机构的公钥内置于浏览器中，
    第一步, 客户端取出`CA公钥`解密CA签名得到一份`摘要`，这份摘要是CA机构把`服务器信息`通过`公开的哈希算法`计算得到的。
    第二部, 客户端将`服务器信息`通过`同样的哈希算法`也得到一份摘要，对比两份摘要，如果一致，说明`服务端信息`确实`去CA认证过`，也就说明证书有效。
)
4. 服务端收到`客户端的公钥`，加上`自己的私钥`，再加上两端的随机数，生成`对称密钥`。
5. 由于两端用的是同一套算法，所以生成的`对称密钥`是相同的，且在握手的过程中，只有`公钥`会发布出去，`私钥`是保密的，所以最终生成的`对称密钥`是安全的，接下来就用这把生成的`对称密钥`进行`对称加密`通信。

## f对称加密
对称加密是指`加密`和`解密`都使用的是`相同的密钥`，目前常见的对称加密算法有 AES128/ AES256 对称加密算法。对称加密的最早的一个原理就是`异或`运算的性质: 比如一串数字作为原文，另一串数字作为密钥，原文和密钥`异或`一次，得到密文。这串密文再和刚才的密钥`异或`一次，又可以解出`原文`。

## f非对称加密
和对称加密只有一个密钥不同，非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。
在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为公钥，服务器自己留下的那个密钥称为私钥。顾名思义，公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开。

### 新浪的 TLSv1.2 握手过程
1. 客户端发送随机数C，以及它支持的密码套件列表
随机数 C 用于帮助对方产生最终的对称密钥 master_secret=f(随机数C,随机数S,pre_master)
client hello    				随机数C, 密码套件列表

2. 服务端发送随机数S, 帮助对方产生最终的对称密钥
服务端选择一个密码套件:
ECDHE密钥交换 + RSA计算公私钥 + AES128对称加密 + GCM分组模式 + SHA256摘要算法
server hello    		 	  随机数S, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
3. 服务器发送CA签名的证书，用于证实服务器身份
客户端拿到证书后如何证实? 
    证书里有"服务器信息+公钥+CA签名的摘要"，CA公钥内置于浏览器中，客户端取出公钥解密CA签名，
 得到一份摘要，将"服务器信息"通过哈希也得到一份摘要，对比，如果两份摘要一致，则说明确实是CA
 加密的，也就说明这份证书确实是CA认证的。
server certificate			certificate(证书)

4. 由于选择了ECDHE，所以服务端要 生成私钥Kb、计算公钥Qb=Kb.P，然后发送"椭圆曲线,P,Qb"
为啥还要发送签名？
	这里的签名是服务器自己的私钥签名，以证明这条数据是服务器发的，因为包含"公钥"这样敏感
的数据，加上签名防止 hacker 假冒，是很有必要的。
server key exchange			server params(曲线, 公钥, 签名)
server hello done				参数传递结束，等待对方公钥

5. 收到证书，验证证书
收到 "椭圆曲线,P,Qb"，生成私钥Ka，计算公钥Qa=Ka.P, 然后发送Qa
根据ECDHE，可以生成pre_master了:
		Qb.Ka = (X,Y)
其中 X 就是 pre_master
计算最终的会话密钥: master_secret=f(随机数C,随机数S,pre-master)
client key exchange			client params(公钥Qa)

6. 服务端收到 Qa，也生成 pre_master: Qa.Kb = (X,Y), 其中 X 就是 pre_master
服务端也计算最终的会话密钥: master_secret = f(随机数C,随机数S,pre-master)，计算结果与 client 相同

7. 经过`TLS`握手, 双方得到`完全相同`的会话密钥，下面进行`AES 对称加密通信`;


# f状态码
1. 信息响应  100~199
2. 成功响应  200~299
3. 重定向响应  300~399
4. 客户端错误响应 400~499
5. 服务端错误响应 500~599

## f100 Continue
这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。

## f101 Switching Protocols
该代码是响应客户端的`Upgrade`请求头发送的, 指明服务器即将切换的协议。
例子: (使用`WebSockets`时切换协议)
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade

## f201 Created
该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。

## f202 Accepted
请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。

## f203 Non-Authoritative Information
服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回`200 OK`的情况下才是合适的。

## f204 No Content
服务器成功处理了请求，但不需要返回任何`实体内容`(Body)。

响应可能通过`实体头部`的形式，返回新的或更新后的`元信息`。如果存在这些头部信息，则应当与所请求的变量相呼应。

如果客户端是`浏览器`的话，那么用户浏览器应`保留发送了该请求的页面`，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。

由于`204`响应被`禁止包含任何消息体`，因此它始终以消息头后的`第一个空行结尾`。

## f205 Reset Content
告诉用户代理重置发送此请求的文档。

## f206 Partial Content
当从客户端发送`Range`范围标头以只请求资源的一部分时，将使用此响应代码。

如果只包含一个数据区间，那么整个响应的 Content-Type 首部的值为所请求的文件的类型，同时包含  Content-Range 首部。

如果包含多个数据区间，那么整个响应的  Content-Type  首部的值为 multipart/byteranges ，其中一个片段对应一个数据区间，并提供  Content-Range 和 Content-Type  描述信息。

### 例子1 只包含一个数据区间的响应:
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 2015 06:25:24 GMT
Last-Modified: Wed, 15 Nov 2015 04:58:08 GMT
Content-Range: bytes 21010-47021/47022
Content-Length: 26012
Content-Type: image/gif

... 26012 bytes of partial image data ...

### 例子2 包含多个数据区间的响应:
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 2015 06:25:24 GMT
Last-Modified: Wed, 15 Nov 2015 04:58:08 GMT
Content-Length: 1741
Content-Type: multipart/byteranges; boundary=String_separator

--String_separator
Content-Type: application/pdf
`Content-Range`: `bytes 234-639/8000`

...the first range...
--String_separator
Content-Type: application/pdf
`Content-Range`: `bytes 4590-7999/8000`

...the second range
--String_separator--


## f301 Moved Permanently
HTTP 301 `永久重定向` 说明请求的资源已经被移动到了由`Location`头部指定的`url`上，是固定的不会再改变。搜索引擎会根据该响应修正。
尽管标准要求浏览器在收到该响应并进行重定向时不应该修改 http method 和 body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用 301，其他情况使用 `308` 来替代 `301`。

# f302 Found
HTTP 302 `临时重定向` 表明请求的资源被`暂时`的移动到了由该 HTTP 响应的响应头`Location`指定的`URL`上。
浏览器会重定向到这个`URL`，但是`搜索引擎`不会对该资源的链接进行更新。

# f304 Not Modified
HTTP 304 `未改变`说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在请求中附带了头部信息`If-None-Match` 或 `If-Modified-Since`。
如果是 200 OK ，响应会带有头部 Cache-Control, Content-Location, Date, ETag, Expires，和 Vary.

# f307 Temporary Redirect
HTTP 307 Temporary Redirect，临时重定向响应状态码，表示请求的资源`暂时地被移动到了`响应的`Location`首部所指向的 URL 上。
原始请求中的请求方法和消息主体会在重定向请求中被重用。在确实需要将重定向请求的方法转换为 GET 的场景下，可以考虑使用 303 See Other 状态码。例如，在使用 PUT 方法进行文件上传操作时，如果需要返回一条确认信息（例如“你已经成功上传了 XYZ”），而不是返回上传的资源本身，就可以使用这个状态码。
## 和 302 的区别  (请求方法不变)
当发送重定向请求的时候，307 状态码可以确保`请求方法和消息主体不会发生变化`。
如果使用 302 响应状态码，一些旧客户端会错误地将请求方法转换为 GET。也就是说，在 Web 中，如果使用了 GET 以外的请求方法:
* 返回 302 状态码，则重定向后的请求方法是不可预测的；
* 返回 307 状态码，之后的请求方法就是可预测的。
对于 GET 请求来说，两种情况没有区别。

# f308 Permanent Redirect
在 HTTP 协议中， 308 Permanent Redirect（永久重定向）是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由 Location 首部指定的 URL 上。浏览器会进行重定向，同时搜索引擎也会更新其链接（用 SEO 的行话来说，意思是“链接汁”（link juice）被传递到了新的 URL）。
## 和 301 的区别  (请求方法不变)
在重定向过程中，`请求方法和消息主体`不会发生改变，然而在返回 301 状态码的情况下，请求方法有时候会被客户端错误地修改为 GET 方法。


// TODO: 写全 HTTP Status Code

# f400 Bad Request  (万能客户端错误响应)
HTTP 400 `Bad Request` 响应状态码表示由于`语法无效`，服务器无法理解该请求。 客户端不应该在未经修改的情况下重复此请求。

# f401 Unauthorized
状态码 401 Unauthorized 代表客户端错误，指的是由于`缺乏`目标资源要求的`身份验证凭证`，发送的请求未得到满足。(如: 没有 token)

# f403 Forbidden
状态码 403 Forbidden 代表客户端错误，指的是服务器端有能力处理该请求，但是`拒绝授权访问`。

这个状态类似于 401，但进入 403 状态后即使重新验证也不会改变该状态。该访问是长期禁止的，并且与应用逻辑密切相关。
例如:
1. 没有足够的权限访问该资源
2. 有 token，但是 token 有多种级别，这种 token 没有访问本接口的权限

# f404 Not Found
状态码 404 Not Found 代表客户端错误，指的是服务器端无法找到所请求的资源。
返回该响应的链接通常称为坏链（broken link）或死链（dead link），它们会导向链接出错处理 (link rot) 页面。
404 状态码并不能说明请求的资源是`临时`还是`永久丢失`。如果服务器知道该资源是永久丢失，那么应该返回 410 (Gone) 而不是 404 。


# fHTTP2
HTTP/2.0 的核心是`提高性能`

## 特点
1. 在`语义`上兼容 HTTP/1
HTTP2 保留了请求方法、URI、状态码等概念，而且同样在 URI 中用 http 作为明文协议，https 作为加密协议。
这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。

2. f头部压缩
http2 使用 HPACK 算法来压缩头部数据。HPACK 算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是“字典”，压缩和解压缩就是查表和更新表的操作。
### f伪头字段
http2 为了方便管理和压缩，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，称呼为`伪头字段`。这些 `伪头字段`会在名字前加一个`:`，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。
### f静态表
HTTP/2 就为一些最常用的头字段定义了一个只读的“静态表”，比如数字`2`代表`:method: GET`，数字`8`代表`:status: 200`。
### f动态表
如果静态表里没有的，就要用到“动态表”，它添加在静态表后面，结构相同，但会在编码解码的时候随时更新。
比如说，第一次发送请求时的`user-agent`字段长是一百多个字节，发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号`65`。那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好。
### 现象
随着在 HTTP/2 连接上发送的报文越来越多，两边的“字典”也会越来越丰富，最终每次的头部字段都会变成一两个字节的代码，原来上千字节的头用几十个字节就可以表示了，压缩效果比 gzip 要好得多。

3. f流与多路复用
`流`是`二进制帧`的`双向传输序列`。
### 特点
* 流是可并发的，一个 HTTP/2 连接上可以同时发出多个流传输数据，也就是并发多请求，实现“多路复用”；
* 客户端和服务器都可以创建流，双方互不干扰；
* 流是双向的，一个流里面客户端和服务器都可以发送或接收数据帧，也就是一个“请求 - 应答”来回；
* 流之间没有固定关系，彼此独立，但流内部的帧是有严格顺序的；
* 流可以设置优先级，让服务器优先处理，比如先传 HTML/CSS，后传图片，优化用户体验；
* 流 ID 不能重用，只能顺序递增，客户端发起的 ID 是奇数，服务器端发起的 ID 是偶数；
* 在流上发送“RST_STREAM”帧可以随时终止流，取消接收或发送；
* 第 0 号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制。
### 复用 tcp 连接
比如说，HTTP/2 在一个连接上使用多个流收发数据，那么它本身默认就会是长连接，所以永远不需要“Connection”头字段（keepalive 或 close）。
又比如，下载大文件的时候想取消接收，在 HTTP/1 里只能断开 TCP 连接重新“三次握手”，成本很高，而在 HTTP/2 里就可以简单地发送一个“RST_STREAM”中断流，而长连接会继续保持。
ID 用完了该怎么办呢？这个时候可以再发一个控制帧“GOAWAY”，真正关闭 TCP 连接。

4. f强化安全
HTTP/2 增强了安全性，要求下层的通信协议至少是`TLS1.2`，而且禁用了很多不安全的密码套件，比如 DES、RC4、CBC、SHA-1 都不能在 HTTP/2 里使用，相当于底层用的是“TLS1.25”。
HTTP/2 要求必须实现的密码套件是 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256，比 TLSv1.2 默认的套件安全强度高了很多。

5. 使用二进制帧
Frame Header(9 Bytes) + Frame Payload
## 帧头
HTTP/2 的帧头很小，只有 9 字节，非常地节省（可以对比一下 TCP 头，它最少是 20 个字节）。
### 帧长度 3Byte
帧开头是 3 个字节的长度（但不包括头的 9 个字节），默认上限是 2^14，最大是 2^24，也就是说 HTTP/2 的帧通常不超过 16K，最大是 16M。
### 帧类型 1Byte
长度后面的一个字节是帧类型，大致可以分成数据帧和控制帧两类，HEADERS 帧和 DATA 帧属于数据帧，存放的是 HTTP 报文，而 SETTINGS、PING、PRIORITY 等则是用来管理流的控制帧。
### 帧标志 1Byte
第 5 个字节是非常重要的帧标志信息，可以保存 8 个标志位，携带简单的控制信息。
常用的标志位有:
* `END_HEADERS`表示`头数据结束`，相当于 HTTP/1 里头后的空行（“\r\n”），
* `END_STREAM` 表示 `单方向数据发送结束`（即 EOS，End of Stream），相当于 HTTP/1 里 Chunked 分块结束标志（“0\r\n\r\n”）。
### 流ID
报文头里最后 4 个字节是流标识符，也就是帧所属的“流”，接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列，按顺序组装起来就实现了虚拟的“流”。
流标识符虽然有 4 个字节，但最高位被保留不用，所以只有 31 位可以使用，也就是说，流标识符的上限是 2^31，大约是 21 亿。


# fHTTP3 
## f队头阻塞 -- tcp固有的问题
举个例子，客户端用 TCP 发送了三个包，但服务器所在的操作系统只收到了后两个包，第一个包丢了。那么内核里的 TCP 协议栈就只能把已经收到的包暂存起来，“停下”等着客户端重传那个丢失的包，这样就又出现了“队头阻塞”。由于这种“队头阻塞”是 TCP 协议固有的，所以 HTTP/2 即使设计出再多的“花样”也无法解决。

Google 在推 SPDY 的时候就已经意识到了这个问题，于是就又发明了一个新的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。

HTTP/3 有一个关键的改变，那就是它把下层的 TCP“抽掉”了，换成了 UDP。因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。


# fXSS  盗取cookie (正常网页中的恶意脚本)
## 讲概念
XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。

## 说原理
XSS靠的是往页面注入恶意脚本来实现攻击。通常情况下，主要有`存储型XSS`、`反射型XSS` 和 `基于DOM的XSS` 三种方式来注入恶意脚本。
### 存储型XSS  恶意专辑名
1. 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
2. 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
3. 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。
#### 案例
2015 年喜马拉雅就被曝出了存储型 XSS 漏洞。起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段 JavaScript，比如
`<script>...attack.js....</script>`。当黑客将专辑名称设置为一段 JavaScript 代码并提交时，喜马拉雅的服务器会保存该段 JavaScript 代码到数据库中。然后当用户打开黑客设置的专辑时，这段恶意脚本就会在用户的页面里执行，恶意脚本可以通过 XMLHttpRequest 或者 Fetch 将用户的 Cookie 数据上传到黑客的服务器。黑客拿到了用户 Cookie 信息之后，就可以利用 Cookie 信息在其他机器上登录该用户的账号，并利用用户账号进行一些恶意操作。
### 反射型XSS  恶意query
在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。
#### 案例
`http://localhost:3000/?xss=<script>alert('你被xss攻击了')</script>`
通过这个操作，我们会发现用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。
### DOM型XSS  网络中修改页面
基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。
### 危害
1. 可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。
2. 可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。
3. 可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
4. 还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。

## fXSS防御
无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。
所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。
### 1.服务器对输入脚本进行过滤或转码
不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行`转码`，比如最典型的：
`code:<script>alert('你被xss攻击了')</script>`
转码后:
`code:&lt;script&gt;alert(&#39;你被xss攻击了&#39;)&lt;/script&gt;`
经过转码之后的内容，如`<script>标签被转换为&lt;script&gt;`，因此即使这段脚本返回给页面，页面也不会执行这段脚本。
### 2.充分利用 CSP  Content-Security-Policy: 内容安全策略
实施严格的 CSP 可以有效地防范 XSS 攻击:
1. 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
2. 禁止向第三方域提交数据，这样用户数据也不会外泄；
3. 禁止执行内联脚本和未授权的脚本；
CSP使用:
1. 配置服务返回`Content-Security-Policy`HTTP头部:
`Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com`
* 图片可以从任何地方加载 (注意 "*" 通配符)。
* 多媒体文件仅允许从 media1.com 和 media2.com 加载 (不允许从这些站点的子域名)。
* 可运行脚本仅允许来自于 userscripts.example.com。
2. `meta`元素也可以被用来配置`CSP`策略，例如
```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### 3.使用 HttpOnly 属性
由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。
通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的:
`set-cookie: NID=189=M8q2I; domain=.google.com; HttpOnly`
使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 document.cookie 来读取这段 Cookie。这样即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。

# fCSRF 陌生链接不要随便点 (恶意网站利用cookie等登录状态)
## 讲概念
CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。

## 说原理
三种方式发起 CSRF:
### 1. 自动发起 Get 请求   (关键在`自动`!!!!)
```html
<html>
  <body>
    <h1>黑客的站点：CSRF攻击演示</h1>
    <img src="https://time.geekbang.org/sendcoin?user=hacker&number=100">
  </body>
</html>
```
黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 极客币就被转移到黑客的账户上去了。
### 2. 自动发起 POST 请求
```html
<html>
<body>
  <h1>黑客的站点：CSRF攻击演示</h1>
  <form id='hacker-form' action="https://time.geekbang.org/sendcoin" method=POST>
    <input type="hidden" name="user" value="hacker" />
    <input type="hidden" name="number" value="100" />
  </form>
  <script> document.getElementById('hacker-form').submit(); </script>
</body>
</html>
```
黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。
### 3. 引诱用户点击链接
```html
<div>
  <img width=150 src=http://images.xuejuzi.cn/1612/1_161230185104_1.jpg> </img> </div> <div>
  <a href="https://time.geekbang.org/sendcoin?user=hacker&number=100" taget="_blank">
    点击下载美女照片
  </a>
</div>
```
黑客页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户上了。
## fCSRF防御
### 1.充分利用好 Cookie 的 SameSite 属性 (一般就是`严格模式Strict`和`宽松模式Lax`)
SameSite 选项通常有 `Strict`、`Lax` 和 `None` 三个值。Strict 最为严格。
* 如果 SameSite 的值是 `Strict`，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从`黑客的页面`中访问`公司服务器`的资源，而 `公司服务器` 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 `公司的服务器` 上的。只有你从 `公司同个域名的站点` 去请求 `公司的资源` 时，才会带上这些 Cookie。
* Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。
* 而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。
### 2.验证请求的来源站点 fRefer fOrigin
这要用到 HTTP 请求头中的 Referer 和 Origin 属性。
* Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址，也就是 URL。
* Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。

因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。
```text
Origin: https://time.geekbang.org
Referer: https://time.geekbang.org/column/intro/216
```
### 3.CSRF Token
使用 token 分为两步:  (也可以用登录，然后返回 token，存在 localStorage，然后每次请求都携带 token)
第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。
```html
<html>
<body>
    <form action="https://time.geekbang.org/sendcoin" method="POST">
      <input type="hidden" name="csrf-token" value="nc98P987bcpncYhoadjoiydc9ajDlcn">
      <input type="text" name="user">
      <input type="text" name="number">
      <input type="submit">
    </form>
</body>
</html>
```
第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。

## 和 XSS 的区别
和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用`服务器的漏洞`和`用户的登录状态`来实施攻击。

XSS 是用户访问正常服务，返回的 html 里夹杂了 hacker 的脚本。
CSRF 是用户访问了 hacker 的服务，返回了恶意脚本。

两种都利用了用户的登录信息(cookie)，XSS是访问本站=>(送cookie)黑站，CSRF是访问黑站=>(伪造请求)本站。


============================================== fCSS ==============================================
# fflex布局 父元素 display:flex  弹性盒模型
## 讲概念
flex布局称为弹性盒模型，是一种一维的布局模型。它给子元素之间提供了空间分布和对齐能力。所谓一维的布局，是指 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。
当使用 flex 布局时，首先想到的是两根轴线 — 主轴和交叉轴。主轴由 flex-direction 定义，另一根轴垂直于它。主轴由 flex-direction 定义，可以取 4 个值：row、row-reverse、column、column-reverse，其中 `reverse` 的含义是交换`起始线`和`终止线`，比如书写英文时左边起始右边终止，而书写阿拉伯文时右边起始左边终止。

# fflex属性 子元素
## 讲概念
flex属性是为了更好地控制 flex 元素，它包含了三个属性:
* flex-grow
* flex-shrink
* flex-basis
这几个 flex 属性的作用其实就是改变了 flex 容器中的`可用空间`的行为。

## 说原理
### 可用空间
假设在 1 个 500px 的容器中，我们有 3 个 100px 宽的元素，那么这 3 个元素需要占 300px 的宽，剩下 200px 的可用空间。在默认情况下，flexbox 的行为会把这 200px 的空间留在最后一个元素的后面。如果期望这些元素能自动地扩展去填充满剩下的空间，那么我们需要去控制可用空间在这几个元素间如何分配，这就是子元素上的那些 flex 属性要做的事。 
### fflex-basis  在这个基准值的基础上缩放 (有单位,如px)
flex-basis 定义了该元素的空间大小（the size of that item in terms of the space），flex 容器里除了元素所占的空间以外的富余空间就是可用空间 available space。 该属性的默认值是 auto 。此时，浏览器会检测这个元素是否具有确定的尺寸。 
如果没有给元素设定尺寸，flex-basis 的值采用元素内容的尺寸。这就解释了: 我们给只要给 Flex 元素的父元素声明 display: flex ，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。
### fflex-grow   增加以填充可用空间 (按比例分配空间)   负值无效，省略时默认值为 1, 初始值为 0。
flex-grow 若被赋值为一个正整数， flex 元素会以 flex-basis 为基础，沿主轴方向增长尺寸。这会使该元素延展，并占据此方向轴上的可用空间（available space）。如果有其他元素也被允许延展，那么他们会各自占据可用空间的一部分。
如果给所有元素设定 flex-grow 值为 1，容器中的`可用空间`会被这些元素平分。它们会延展以填满容器主轴方向上的空间。
flex-grow 属性可以按比例分配空间。如果第一个元素 flex-grow 值为 2，其他两个元素值为 1，则第一个元素将占有 2/4, 另外两个元素各占有1/4。
### fflex-shrink 收缩以适应整体空间   负值无效，省略时默认值为1，初始值为 1。
flex-grow属性是处理 flex 元素在主轴上增加空间的问题，相反flex-shrink属性是处理 flex 元素收缩的问题。如果我们的容器中没有足够排列 flex 元素的空间，那么可以把 flex 元素flex-shrink属性设置为正整数来缩小它所占空间到flex-basis以下。与flex-grow属性一样，可以赋予不同的值来控制 flex 元素收缩的程度 —— 给flex-shrink属性赋予更大的数值可以比赋予小数值的同级元素收缩程度更大。

## 说用法
Flex 简写形式允许我们把三个数值按 — flex-grow，flex-shrink，flex-basis 这个顺序书写。
可以使用一个，两个或三个值来指定 flex属性。
### 1.单值语法
#### 1.1 无单位数
一个无单位数`number`: 它会被当作flex:`number` 1 0; `flex-shrink`的值被假定为 1，然后`flex-basis`的值被假定为0。
##### fflex:1
比如 flex:1 相当于 flex: 1 1 0，含义是 flex-grow为1，flex-shrink为1，flex-basis为0。
(flex-basis为 0 的基础上伸缩，增长比例是1，收缩比例是1。)
#### 1.2 宽度值
一个有效的宽度 (width)值：它会被当作`flex-basis`的值。
#### 1.3 关键字
关键字none，auto或initial.
* flex: initial
* flex: auto
* flex: none
##### fflex:initial
flex: initial 是把 flex 元素重置为 Flexbox 的初始值，它相当于 flex: 0 1 auto。在这里 flex-grow 的值为 0，所以 flex 元素不会超过它们 flex-basis 的尺寸。flex-shrink 的值为 1, 所以可以缩小 flex 元素来防止它们溢出。flex-basis 的值为 auto. Flex 元素尺寸可以是在主维度上设置的，也可以是根据内容自动得到的。
#### fflex:auto
flex: auto 等同于 flex: 1 1 auto；和上面的 flex:initial 基本相同，但是这种情况下，flex 元素在需要的时候既可以拉伸也可以收缩。
#### fflex:none
flex: none 可以把 flex 元素设置为不可伸缩。它和设置为 flex: 0 0 auto 是一样的。元素既不能拉伸或者收缩，但是元素会按具有 flex-basis: auto 属性的 flexbox 进行布局。

### 2.双值语法
第一个值必须为一个无单位数，并且它会被当作`flex-grow`的值。第二个值必须为以下之一:
#### 2.1 第二个值是无单位数
它会被当作 `flex-shrink` 的值。  如 flex: 1 1。
#### 2.2 第二个值是一个有效的宽度值
它会被当作 `flex-basis` 的值。 如 flex: 1 100px。

### 3.三值语法
第一个值必须为一个无单位数，并且它会被当作 `flex-grow` 的值。
第二个值必须为一个无单位数，并且它会被当作  `flex-shrink` 的值。
第三个值必须为一个有效的宽度值(如px)，并且它会被当作 `flex-basis` 的值。
如: `flex: 1 1 100px`


# fBFC   Block Formatting Contex
## 讲概念
BFC 是块级格式化上下文，它是 Web 页面的可视 CSS 渲染的一部分，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。

## 说实现
f创建BFC的方式:
1. 根元素 `html`
2. 浮动元素（float 值不为 none）
3. 绝对定位元素（position 值为 absolute 或 fixed）
4. 行内块元素（display 值为 inline-block）
5. 表格单元格（display 值为 table-cell，HTML 表格单元格默认值）
6. 表格标题（display 值为 table-caption，HTML 表格标题默认值）
7. 匿名表格单元格元素（display 值为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、tr、tbody、thead、tfoot 的默认值）或 inline-table）
8. overflow 值不为 visible、clip 的块元素
9. display 值为 flow-root 的元素
10. contain 值为 layout、content 或 paint 的元素
11. 弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器
12. 网格元素（display 值为 grid 或 inline-grid 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器
13. 多列容器（column-count 或 column-width (en-US) 值不为 auto，包括column-count 为 1）
14. column-span 值为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中 (规范变更, Chrome bug)

## 说用途
格式化上下文可用于:
1. 包含内部浮动
2. 排除外部浮动
3. 阻止外边距重叠
### f包含内部浮动  (浮动元素在目标元素内)
让浮动内容和周围的内容等高。
比如，我们让 <div> 元素浮动，并给它一个 border 效果。<div> 里的内容现在已经在浮动元素周围浮动起来了。由于浮动的元素比它旁边的元素高，所以 <div> 的边框`穿出了浮动`，浮动脱离了文档流。
解决办法是:
1. foverflow: auto
在创建包含浮动元素的 BFC 时，通常的做法是设置父元素 overflow: auto 或者其它除默认的 overflow: visible 以外的值。<div> 元素变成布局中的迷你布局，任何子元素都会被包含进去。使用 overflow 创建新的 BFC，是因为 overflow 属性会告诉浏览器应该怎样处理溢出的内容。如果使用它仅仅为了创建 BFC，你可能会遇到不希望出现的滚动条或阴影，需要注意。另外，对于后续的开发者，可能不清楚当时为什么使用 overflow，所以最好添加一些注释来解释为什么这样做。
2. fdisplay: flow-root
一个新的 display 属性的值，它可以创建无副作用的 BFC。在父级块中使用 display: flow-root 可以创建新的 BFC。给 <div> 元素设置 display: flow-root 属性后，<div> 中的所有内容都会参与 BFC，浮动的内容不会从底部溢出。我们可以从 flow-root 这个值的名字上看出来，它创建一个新的用于流式布局的上下文，类似于浏览器的根（html）元素。
```html
<style>
  section {
  height: 150px;
  }
  .box {
    background-color: rgb(224, 206, 247);
    border: 5px solid rebeccapurple;
  }
  .box[style] {
    background-color: aliceblue;
    border: 5px solid steelblue;
  }
  .float {
    float: left;
    width: 200px;
    height: 100px;
    background-color: rgba(255, 255, 255, .5);
    border:1px solid black;
    padding: 10px;
  }
</style>
<section>
  <div class="box">
    <div class="float">I am a floated box!</div>
    <p>I am content inside the container.</p>
  </div>
</section>
<section>
  <div class="box" style="overflow:auto">
    <div class="float">I am a floated box!</div>
    <p>I am content inside the <code>overflow:auto</code> container.</p>
  </div>
</section>
<section>
  <div class="box" style="display:flow-root">
    <div class="float">I am a floated box!</div>
    <p>I am content inside the <code>display:flow-root</code> container.</p>
  </div>
</section>
```
### f排除外部浮动  (浮动元素和目标元素同级)
有时候`浮动元素`在目标元素的同级，为了不影响同级元素，可以给同级元素增加 display:flow-root 属性。
```html
<style>
  section {
  height:150px;
  }
  .box {
    background-color: rgb(224, 206, 247);
    border: 5px solid rebeccapurple;
  }
  .box[style] {
    background-color: aliceblue;
    border: 5px solid steelblue;
  }
  .float {
    float: left;
    overflow: hidden; /* required by resize:both */
    resize: both;
    margin-right:25px;
    width: 200px;
    height: 100px;
    background-color: rgba(255, 255, 255, .75);
    border: 1px solid black;
    padding: 10px;
  }
</style>
<section>
  <div class="float">Try to resize this outer float</div>
  <div class="box"><p>Normal</p></div>
</section>
<section>
  <div class="float">Try to resize this outer float</div>
  <div class="box" style="display:flow-root"><p><code>display:flow-root</code><p></div>
</section>
```
### f外边距重叠
创建新的 BFC 避免两个相邻的 div 之间`外边距重叠`。比如，在受影响的元素外层加一个div，增加 overflow:hidden 属性。
```html
<style>
  .blue, .red-inner {
  height: 50px;
  margin: 10px 0;
  }
  .blue {
    background: blue;
  }
  .red-outer {
    overflow: hidden;
    background: red;
  }
</style>
<div class="blue"></div>
<div class="red-outer">
  <div class="red-inner">red inner</div>
</div>
```
#### f外边距重叠概念
块的上外边距 (margin-top)和下外边距 (margin-bottom)有时合并 (折叠) 为单个边距，其大小为单个边距的最大值 (或如果它们相等，则仅为其中一个)，这种行为称为边距折叠。

有三种情况会形成外边距重叠:
1. 同一层相邻元素之间
相邻的两个元素之间的外边距重叠，除非后一个元素加上 clear:both 清除浮动。
下面这个例子如果以为边界会合并的话，理所当然会猜测上下 2 个元素会合并一个 100px 的边界范围，但其实会发生边界折叠，只会挑选最大边界范围留下，所以这个例子的边界范围其实是 87px。
```html
<p style="margin-bottom: 13px;">下边界范围会...</p>
<p style="margin-top: 87px;">...会跟这个元素的上边界范围重叠。</p>
```
解决办法: 加个 overflow:hidden 的父级
```html
<p style="margin-bottom: 13px;">下边界范围会...</p>
<div style="overflow: hidden;">
  <p style="margin-top: 87px;">...会跟这个元素的上边界范围重叠。</p>
</div>
```
2. 没有内容将父元素和后代元素分开
2-1. 没有边框border，内边距padding，行内内容，
2-2. 没有创建`块级格式上下文`或`清除浮动`来分开一个块级元素的上边界margin-top 与其内一个或多个后代块级元素的上边界margin-top；
2-3. 没有边框，内边距，行内内容，高度height，最小高度min-height或 最大高度max-height 来分开一个块级元素的下边界margin-bottom与其内的一个或多个后代后代块元素的下边界margin-bottom，则就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。
```html
<section style="margin-top: 13px; margin-bottom: 87px;">
  <header style="margin-top: 87px;">上边界重叠 87px</header>
  <main></main>
  <footer style="margin-bottom: 13px;">下边界重叠 87px</footer>
</section>
```
3. 空的块级元素
当一个块元素上边界margin-top 直接贴到元素下边界margin-bottom时也会发生边界折叠。这种情况会发生在一个块元素完全没有设定边框border、内边距padding、高度height、最小高度min-height 、最大高度max-height 、内容设定为 inline 或是加上clear-fix的时候。
```html
<p style="margin: 0">上边界范围是 87 ...</p>
<div style="margin-top: 13px; margin-bottom: 87px;"></div>
<p style="margin: 0">... 上边界范围是 87</p>
```

# f浮动元素
## 讲概念
浮动元素是 float 的计算值非 none 的元素。当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。(浮动内容仍然遵循`盒子模型`诸如外边距和边界，设置右边距仍会撑开右边的文本等..)
## 说危害
元素浮动以后，所有在浮动下面的自身不浮动的内容都将围绕浮动元素进行包装，比如`文本`和`内联元素`将环绕`浮动元素`，如果没有处理这些元素，网页布局都会变得很糟糕。
## f清除浮动
清除浮动是指强制元素移至任何浮动元素下方。
### 1. clear:both
1. 增加一个空元素
```html
<div class="float"></div>
<!-- 增加一个 clear:both 层以清除上面的浮动 !-->
<div style="clear: both"></div>
```
2. 给父元素添加伪元素
```css
.parent::after{
  content: "";
  display: block;
  height: 0;
  clear:both;
}
```
### 2. 触发父级元素的BFC
```css
/* 触发父元素BFC, 下面注释的属性均可触发BFC */
.parent {
  display: flow-root;
  /* overflow: hidden; */
  /* float: left; */
  /* position: absolute; */
}
```
比如，`div`浮动，并给它一个 border 效果。<div> 里的内容现在已经在浮动元素周围浮动起来了。由于浮动的元素比它旁边的元素高，所以 <div> 的边框穿出了容器，浮动脱离了文档流。为了把它包裹进父级，这时可以在父级容器增加以下属性:
* display: flow-root;  // 无副作用，推荐
* overflow: auto/hidden;  // 视情况使用，可能产生滚动条 或 截断了内容
* position: relative;  // 视情况使用，改变了定位
* display: flex:  // 视情况使用，改成了弹性盒模型
...搜索[f创建BFC的方式]


# f水平垂直居中  (f居中、f垂直、f不定宽高)
五种方式: 弹性布局居中设置, 相对&绝对定位+transform:translate, 相对&绝对定位+margin:auto, 相对&绝对定位+margin:负值， 弹性布局+margin:auto。
## 1. 弹性布局居中设置
设置父级 display: flex, 然后 align-items: center; 保持垂直居中， justify-content: center; 保持水平居中。
移动端用得多。
### 注意点
考虑浏览器兼容问题
```html
<head>
  <style>
    .container {
      display: flex;
      align-items: center; 
      justify-content: center;
      /* 页面居中: 和body同宽高 */
      width: 100%;
      height: 100vh;
    }
    .box {
      width: 300px;
      height: 120px;
      background-color: lightblue;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="box"></div>
  </div>
</body>
```
## 2. 相对&绝对定位 + transform:translate
父元素相对定位，子元素绝对定位。子元素左和上方向都偏移 50%，再通过 transform: translate(-50%, -50%)，调整回来。 (用了百分比，不定宽高也能使用)
### 注意点
需要考虑浏览器兼容问题
```html
<head>
  <style>
    .container {
      position: relative;
      width: 100%;
      height: 100vh;
    }
    .box {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      height: 120px;
      background-color: lightblue;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="box"></div>
  </div>
</body>
```
## 3. 相对&绝对定位+margin:auto
父元素相对定位，子元素绝对定位。设置子元素四个方向的值都为 0，并将 margin 设置为 auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。
### 注意点
盒子可以不定宽高，但必须有宽高。
```html
<head>
  <style>
    .container {
      position: relative;
      width: 100%;
      height: 100vh;
    }
    .box {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      margin: auto;
      width: 300px;
      height: 120px;
      background-color: lightblue;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="box"></div>
  </div>
</body>
```
## 4. 相对&绝对定位+margin:负值
父元素相对定位，子元素绝对定位。子元素左和上方向都偏移 50%，再通过 margin-left自身宽度一半的负值， margin-top自身高度一半的负值，调整回来。
### 注意点
盒子宽高已知，不定长的情况下需要动态调整。
```html
<head>
  <style>
    .container {
      position: relative;
      width: 100%;
      height: 100vh;
    }
    .box {
      position: absolute;
      top: 50%;
      left: 50%;
      margin-top: -50px;
      margin-left: -50px;
      width: 300px;
      height: 120px;
      background-color: lightblue;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="box"></div>
  </div>
</body>
```
## 5. f弹性布局+margin:auto
父级弹性布局，子元素 margin: auto;
### 注意点
需考虑浏览器兼容性。
```html
<head>
  <style>
    .container {
      display: flex;
      width: 100%;
      height: 100vh;
    }
    .box {
      margin: auto;
      width: 300px;
      height: 120px;
      background-color: lightblue;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="box"></div>
  </div>
</body>
```
这里蛮有意思的 如果不在弹性布局中 `margin:auto;`只能做到水平居中。

# fvisibility:hidden 和 display:none 的区别  (f隐藏 fhidden)
这两个属性都是让元素隐藏，不可见。两者区别如下:
1. 在渲染树中
- `display:none`会让元素完全从渲染树中消失，渲染时不会占据任何空间；
- `visibility:hidden`不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。
2. 是否是继承属性
- `display:none`是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；
- `visibility:hidden`是继承属性，子孙节点消失是由于继承了`hidden`，通过设置`visibility:visible`可以让子孙节点显示；
3. 重排和重绘
修改常规文档流中元素的 `display` 通常会造成文档的重排，但是修改`visibility`属性只会造成本元素的重绘；
4. 如果使用读屏器，设置为`display:none`的内容不会被读取，设置为`visibility:hidden`的内容会被读取。

# f伪元素
TODO

# f伪类
CSS 伪类 是添加到选择器的关键字，指定要选择的元素的特殊状态。例如，:hover 可被用于在用户将鼠标悬停在按钮上时改变按钮的颜色。
```css
button:hover {
  color: blue;
}
```
伪类连同伪元素一起，他们允许你不仅仅是根据文档 DOM 树中的内容对元素应用样式，而且还允许你根据诸如像导航历史这样的外部因素来应用样式（例如 :visited），同样的，可以根据内容的状态（例如在一些表单元素上的 :checked），或者鼠标的位置（例如 :hover 让你知道是否鼠标在一个元素上悬浮）来应用样式。
## 常用的伪类
:link    匹配所有尚未访问的链接，包括那些已经给定了其他伪类选择器的链接。
:visited 匹配用户已访问过的链接。
:hover   适用于用户使用指示设备虚指一个元素（没有激活它）的情况。
:active  匹配被用户激活的元素。它让页面能在浏览器监测到激活时给出反馈。当用鼠标交互时，它代表的是用户`按下按键`和`松开按键`之间的时间。
:checked 匹配任何处于选中状态的radio, checkbox 或 select元素中的 option。
:focus   匹配获得焦点的元素（如表单输入）。当用户点击或触摸元素或通过键盘的 “tab” 键选择它时会被触发。
:host    匹配包含其内部使用的 CSS 的 shadow DOM 的根元素 - 换句话说，这允许你从其 shadow DOM 中选择一个自定义元素。
:nth-last-of-type(n)  选中倒数第n个type类型的元素, 注意倒数的索引从1开始。
:nth-of-type(n)       指定一个实际参数n，这个参数使用一种模式来匹配哪些元素应该被选中, 如 2n+1奇数, 2n偶数, int代表从1开始的索引。
:root    匹配文档树的根元素。对于 HTML 来说，:root 表示 <html> 元素，除了优先级更高之外，与 html 选择器相同。

### flink CSS伪类  <a>的LVHA的L
选中元素当中的链接。它将会选中所有尚未访问的链接，包括那些已经给定了其他伪类选择器的链接（例如:hover选择器，:active选择器，:visited选择器）。为了可以正确地渲染链接元素的样式，:link 伪类选择器应当放在其他伪类选择器的前面，并且遵循 LVHA 的先后顺序，即：:link — :visited — :hover — :active。:focus伪类选择器常伴随在:hover伪类选择器左右，需要根据你想要实现的效果确定它们的顺序。
```css
a:link { color: blue; }          /* 未访问链接 */
a:visited { color: purple; }     /* 已访问链接 */
a:hover { background: yellow; }  /* 用户鼠标悬停 */
a:active { color: red; }         /* 激活链接 */
```

### fvisited CSS伪类  <a>的LVHA的L
匹配用户已访问过的链接。
```html
<a href="#test-visited-link">你是否访问过此链接？</a>
<a href="">你已经访问过此链接。</a>
```
```css
a:visited {
  background-color: yellow;
  border-color: hotpink;
  color: hotpink;
}
```

### fhover CSS伪类  <a>的LVHA的H
适用于用户使用指示设备虚指一个元素（没有激活它）的情况。这个样式会被任何与链接相关的伪类重写，像:link、:visited 和 :active 等。为了确保生效，:hover 规则需要放在 :link 和 :visited 规则之后，但是在:active 规则之前，按照 LVHA 的顺序声明 :link－:visited－:hover－:active。
#### 例子
纯 CSS 的下拉按钮
```html
<div class="menu-bar">
  <ul>
    <li>
      <a href="example.html">Menu</a>
      <ul>
        <li>
          <a href="example.html">Link</a>
        </li>
        <li>
          <a class="menu-nav" href="example1.html">Submenu1</a>
          <a class="menu-nav" href="example2.html">Submenu2</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
```
```css
div.menu-bar ul ul {
  display: none;
}
div.menu-bar li:hover > ul {
  display: block;
}
```

### factive CSS伪类
匹配被用户激活的元素。它让页面能在浏览器监测到激活时给出反馈。当用鼠标交互时，它代表的是用户按下按键和松开按键之间的时间。
```css
a:active {
  color: red;
}
```
`:active`伪类一般被用在 <a> 和 <button> 元素中。这个伪类的一些其他适用对象包括包含激活元素的元素，以及可以通过他们关联的<label>标签被激活的表格元素。
这个样式可能会被后声明的其他链接相关的伪类覆盖，这些伪类包括 :link，:hover 和 :visited。为保证样式生效，需要把 :active 的样式放在所有链接相关的样式之后。这种链接伪类先后顺序被称为 LVHA 顺序：:link — :visited — :hover — :active。
```css
a:link { color: blue; }          /* 未访问链接 */
a:visited { color: purple; }     /* 已访问链接 */
a:hover { background: yellow; }  /* 用户鼠标悬停 */
a:active { color: red; }         /* 激活链接 */
p:active { background: #eee; }   /* 激活段落 */
```

### ffocus CSS伪类
表示获得焦点的元素（如表单输入）。当用户点击或触摸元素或通过键盘的 “tab” 键选择它时会被触发。
```html
<input class="red-input" value="聚焦时字体变红"><br>
<input class="blue-input" value="聚焦时字体变蓝">
```
```css
/* 聚焦时字体变红 */
.red-input:focus {
  background: yellow;
  color: red;
}
/* 聚焦时字体变蓝 */
.blue-input:focus {
  background: yellow;
  color: blue;
}
```

### fchecked CSS伪类
匹配任何处于选中状态的radio, checkbox 或 select元素中的 option。
```html
<div>
  <input type="radio" name="my-input" id="yes">
  <label for="yes">Yes</label>
  <input type="radio" name="my-input" id="no">
  <label for="no">No</label>
</div>
<div>
  <input type="checkbox" name="my-checkbox" id="opt-in">
  <label for="opt-in">Check me!</label>
</div>
```
```css
/* 选中项的label字色变红 */
input:checked + label {
  color: red;
}
/* radio选中项加orange阴影 */
input[type="radio"]:checked {
  box-shadow: 0 0 0 3px orange;
}
/* checkbox选中项加hotpink阴影 */
input[type="checkbox"]:checked {
  box-shadow: 0 0 0 3px hotpink;
}
```

### froot CSS伪类
匹配文档树的根元素。对于 HTML 来说，:root 表示 <html> 元素，除了优先级更高之外，与 html 选择器相同。
```css
/* 在声明全局 CSS 变量时 :root 会很有用 */
:root {
  --main-color: hotpink;
  --pane-padding: 5px 42px;
}
```

### fnth-of-type(n) CSS伪类
针对具有一组兄弟节点的标签，用 n 来筛选出在一组兄弟节点的位置。nth-of-type伪类指定一个实际参数n，这个参数使用一种模式来匹配哪些元素应该被选中。
```html
<div>
  <div>这段不参与计数。</div>
  <p>这是第一段。</p>
  <p>这是第二段。</p>
  <div>这段不参与计数。</div>
  <p>这是第三段。</p>
  <p>这是第四段。</p>
</div>
```
```css
/* 奇数段 */
p:nth-of-type(2n+1) {
  color: red;
}
/* 偶数段 */
p:nth-of-type(2n) {
  color: blue;
}
/* 第一段 */
p:nth-of-type(1) {
  font-weight: bold;
}
```

### fnth-last-of-type(n) CSS伪类
选中倒数第n个type类型的元素, 注意倒数的索引从1开始。 
```html
<div>
  <span>This is a span.</span>
  <span>This is another span.</span>
  <em>This is emphasized.</em>
  <!-- 这个元素被选中，背景变为石灰色(浅绿) -->
  <span>Wow, this span gets limed!!!</span>
  <em>This is emphasized2.</em>
  <span>Here is one last span.</span>
</div>
```
```css
/* 选中倒数第2个span元素 */
span:nth-last-of-type(2) {
  background-color: lime;
}
```

### fhost CSS伪类
```html
<!-- context-span 是自定义元素 -->
<context-span>Red</context-span>
<context-span>Custom elements</context-span>
<context-span class="footer">Chris Mills</context-span>
```
```css
/* 规则设置<context-span>元素的所有实例的样式（此实例中为影子根元素）的所有实例。 */
:host { 
  background: rgba(0,0,0,0.1); 
  padding: 2px 5px; 
} 
```

============================================== fHTML ==============================================
# fDOCTYPE
文档类型声明，全称是 document type，告知浏览器用什么文档标准解析这个文档。
## 例子
比如加 html 是让浏览器以 W3C 标准解析文档。
```html
<!DOCTYPE html>
<html>
  ...
</html>
```

# fHTML5 新特性
从 标签、属性、存储、API 四个方面来说:
## 标签
在标签上，新增语义化标签 aside, figure, section, header, footer, nav 等，增加多媒体标签 video 和 audio, 使得样式和结构更加分离。
## 属性
在属性上，增强表单，主要是增强了 input 的 type 属性; meta 增加 charset 属性以设置字符集; script 增加 async 以一步加载脚本。
## 存储
在存储上，增加 localStorage, sessionStorage 和 IndexDB 存储 web 数据。
## API
在 API 上，新增 拖放API, 地理定位, SVG绘图, canvas绘图, Web Worker, WebSocket。

# fdefer vs fasync
这两个属性都是 script 标签的属性，都有异步执行的作用，能够防止浏览器解析阻塞的 Javascript`。解析阻塞的 Javascript 会导致浏览器必须加载并且执行脚本，之后才能继续往下解析。
## fasync
对于普通脚本，如果存在 async 属性，那么普通脚本会被并行请求，下载完成后会`立即解析和执行`。
对于模块脚本，如果存在 async 属性，那么脚本及其所有依赖都会在延缓队列中执行，因此它们会被并行请求，下载完成后会立即解析和执行。
## fdefer
这个布尔属性被设定用来通知浏览器该脚本将在`文档完成解析`后，触发`DOMContentLoaded`事件前执行。

# fmeta
meta 标签用于描述文档的元信息，如网站字符集、响应头、移动设备的视口大小、作者、描述、关键词，它通过键值对的形式来定义信息。常用的属性如 charset, http-equiv, 以及 name-content 形式定义的属性。
## fcharset 字符集
这个属性声明了文档的字符编码。如果使用了这个属性，其值必须是与 ASCII 大小写无关（ASCII case-insensitive）的"utf-8"。
```html
<meta charset="UTF-8">
```
## fhttp-equiv HTTP头部(请求+响应)
```html
<!-- 内容安全策略  禁用不安全的内联/动态执行，只允许通过 https 加载这些资源（如图片、字体、脚本等） -->
<meta http-equiv="Content-Security-Policy" content="default-src https:">
<!-- 声明文档的类型 -->
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<!-- 重新载入页面的时间间隔10秒 -->
<meta http-equiv="refresh" content="10">
```
## name-content 对
定义文档的标准元数据，其中 name 作为元数据的名称，content 作为元数据的值。常用的元数据有:
* viewport: 定义视口大小，目前只用于移动设备。
* application-name: 表示网页中运行的应用程序名称。
* author: 文档作者的名字。
* color-scheme: 指定与当前文档兼容的一种或多种配色方案。
* referrer：控制由当前文档发出的请求的 HTTP Referer 请求头。

```html
<!-- 视口宽度为设备宽度; 设备宽度与视口大小之间的缩放比例为1:1 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- 网页中运行的应用程序名称 -->
<meta name="application-name" content="app">
<!-- 文档作者的名字 -->
<meta name="author" content="mike">
<!-- 文档更喜欢黑暗模式，但在光模式下也可以在功能上呈现 -->
<meta name="color-scheme" content="dark light">
<!-- 
  Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址，也就是 URL。
  Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。

  Origin: https://time.geekbang.org  (没有Path)
  Referer: https://time.geekbang.org/column/intro/216  (有Path)

  Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。
-->
<!-- 只发送当前文档的 origin -->
<meta name="referrer" content="origin">
```
### fviewport 有哪些属性
* width: 定义 viewport 的宽度，如果值为正整数，则单位为像素。
* initial-scale: 定义设备宽度（宽度和高度中更小的那个：如果是纵向屏幕，就是 device-width，如果是横向屏幕，就是 device-height）与 viewport 大小之间的缩放比例。范围 [0.0~10.0]
* maximum-scale: 定义缩放的最大值，必须大于等于 minimum-scale，否则表现将不可预测。浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。[0.0~10.0]
* minimum-scale: 定义缩放的最小值，必须小于等于 maximum-scale，否则表现将不可预测。浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。[0.0~10.0]
* user-scalable: 默认为 yes，如果设置为 no，用户将无法缩放当前页面。浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。[yes|no]

# fhref 和 fsrc 有什么区别
href（hyperReference）即超文本引用：当浏览器遇到href时，会并行的地下载资源，不会阻塞页面解析，例如我们使用<link>引入CSS，浏览器会并行地下载CSS而不阻塞页面解析。
src（resource）即资源，当浏览器遇到src时，会暂停页面解析，直到该资源下载或执行完毕。
```html
<link href="style.css" rel="stylesheet" />
<!-- ..body.. -->
<script src="script.js"></script>
```
